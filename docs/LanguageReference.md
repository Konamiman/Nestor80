# Nestor80 assembler language reference

This documents details the source file format supported by Nestor80 and lists all the available assembler instructions (called "pseudo-operators" in the MACRO-80 manual), both the ones inherited from MACRO-80 and the ones newly introduced by Nestor80.


## Document conventions

The following icons are used in this document:

🆕 A "new" icon is used when introducing a feature or instruction that is new in Nestor80 (it wasn't available in MACRO-80).

✨ A "sparks" icon is used when referring to a feature or instruction that was already available in MACRO-80 but has been enhanced or improved in a backwards-compatible way in Nestor80.

🚫 A "forbidden" icon is used to refer to a MACRO-80 feature or instruction that is not available or has changed in a backwards-incompatible way in Nestor80. Old source code intended for MACRO-80 and relying in such features or instructions will likely require changes before being suitable for assembly with Nestor80.

⚠ A "warning" icon is used when discussing a tricky, subtle or confusing subject; or in general to bring attention to an important concept.

Text in _italics_ will be used the first time a new term or concept is introduced. Alternatively, when a concept or term that is introduced in a later section is used, it will link to the defining section.


## Basic concepts

Before detailing the assembler language reference a couple of concepts related to how the assembler works will be introduced.


### Passes

Nestor80 is a _two pass assembler_. This means that the source code is processed twice: the first time the assembler determines how many bytes each source code line will use in the _target program_ (the contents of the binary file resulting from processing the source code) and updates the current _location counter_ (the pointer in Z80 memory where the code generated by each line will be loaded) accordingly, using this information to assign the appropriate values to labels. The second time, already with all the label values at hand, is when the code is actually assembled.

Let's see a simple example:

```
org 100h
call PROGRAM
ret
PROGRAM:
;Some code here
RET
```

In pass 1 the assembler does the following:

1. It sees a `CALL PROGRAM` instruction and although the value of `PROGRAM` is still unknown, one thing that is for sure is that the line will use three bytes of memory in the target program. Thus, the current location counter is updated to 103h.
2. It sees a `RET` instruction and knows that it will use one byte, thus the location counter is updated to 104h.
3. It sees the definition of the `PROGRAM` label and assigns it the value of the current location counter, 104h.
4. It processes the rest of the code accordingly.

In pass 2 the assembler already knows the value of `PROGRAM` and thus processes the second line as if it was `CALL 0104h`, writing `CDh 04h 01h` to the target program.

A similar processing happens for other types of symbols that don't depend on the location counter but may be unknown when found in pass 1, e.g. constants:

```
call CHPUT
ret
CHPUT equ 00A2h
```

Usually the fact that the assembly process takes two passes is transparent for the developer, but the `IF1` and `IF2` instructions exist for advanced scenarios in which it's convenient to process different blocks of source code depending on the current pass. This is typically used to prevent the output of duplicated messages during the assembly process with `.PRINT`, `.WARN` or `.ERR`.

Here's an advanced example from the source code of [Nextor](https://github.com/Nextor). The following macro will store the value of a given symbol, but if the symbol is undefined by the time the macro is expanded in pass 2, it will be specified as an external symbol reference (with the `##` suffix); the `DEFW 0` in pass 1 is needed to keep the location counter consistent in both passes:

```
DEFA MACRO ADDR
 IF1
  DEFW	0
 ELSE
  IFDEF	ADDR
   DEFW	ADDR
  ELSE
   DEFW	ADDR##
  ENDIF
 ENDIF
ENDM
```

⚠ Unlike MACRO-80, Nestor80 will skip pass 2 if errors are found in pass 1  (but not if only warnings are found). Thus during the development process it's possible to find that some assembly errors seemingly "appear from nowhere" after some other errors were fixed (the former being errors found in pass 2 and the later being errors found in pass 1). A fatal error will terminate the assembly process immediately.

The location counter can be temporarily modified to account for code that will be executed at a different address, see `.PHASE`.


### Absolute and relocatable code

Nestor80 can produce both absolute 🆕 and relocatable files.

* An _absolute file_ contains code "ready to use", intended to be loaded and executed at the fixed memory locations indicated by the `ORG` instructions found in code (or begninning at address 0, if no such instructions are provided). Most assemblers produce only absolute files.

* _Relocatable files_ have [a dedicated format](RelocatableFileFormat.md) and contain relocatable code, that is, "pre-assembled" code in which labels are flagged as being relative to the memory address where the target program will be loaded and symbols may be flagged as _external_, that is, defined in other relocatable file.

Relocatable files can't be executed, instead a linker (typically LINK-80) must be used to convert it into an absolute file by providing the actual loading memory addresses for the target program. The linker is typically used to "glue together" two or more of these files (and linking public symbols with the corresponding external symbols).

It's possible to instruct Nestor80 to produce an absolute file or a relocatable file by using the `--build-type` command line argument, but by default Nestor80 will decide the appropriate type automatically. The decision is taken as follows:

> If an `ORG` instruction is found in the source code before a CPU instruction, a label defined as public with  `::`, or any of the following instructions: `CSEG`, `DSEG`, `COMMON`, `DEFB`, `DEFW`, `DEFS`, `DC`, `DEFZ`, `PUBLIC`, `EXTRN`, `.REQUEST`, then the build type will be absolute; otherwise the build type will be relocatable.

Put it another way, if you want your code to be automatically detected as intended to be assembled as absolute, use an `ORG` instruction as the first "effective" source code line (so the first line except blanks, comments, macro definitions and constant definitions).

⚠ If the build type is forced to absolute with `--build-type` but the code contains no `ORG` instructions, an implicit `ORG 0` at the beginning of the code is assumed.

Some assembler instructions make sense only in the context of relocatable code, for example `CSEG`, `DSEG`, `PUBLIC` OR `EXTRN`; these instructions will do nothing, and the assembler will throw warnings, if they are found while assembling absolute code. 

See "Writing relocatable code" for more details about how relocatable code programming works.


## Source code format

Nestor80 converts source code files to absolute or relocatable files. A source code file is a text file in which each line is either blank, a _comment_, or a _statement_; lines
are processed one by one. The maximum supported line length is 1034 characters ✨ and all the usual line ending conventions are supported (CR+LF characters, LF only, and CR only). ✨ 
Spaces and tabs are treated equivalently, and those found at the beginning and at the end of the line are removed before the line is processed.

A comment-only line starts with a semicolon character, `;`,  and has no effect in the assembly process. A statement has the following format:

```
[label:[:]] [operator] [arguments] [;comment]
```

Any number of spaces or tabs can be used to separate the statement components.

A _label_ is a type of symbol that has the value of the location counter at the time it's defined (the value that the location counter has when the line is processed).
A label definition must end with either `:` or `::`; the later is used when assembling relocatable code to indicate that the label is public.

An _operator_ is a word that can be either the mnemonic of a CPU instruction (e.g. `LD`) or an assembler instruction. An _assembler instruction_ (called "pseudo-operator"
in the MACRO-80 manual) is an instruction for the assembler itself, for example `ORG` instructs the assembler to change the value of the current location counter.

> ⚠ In this manual the word "instruction" alone will be used to refer to assembler instructions, as opposed to CPU instructions.

The comment, if present, runs until the end of the line and has no effect in the assembly process. Multiline comments are supported by using the `.COMMENT` instruction.

Nestor80 supports Z80 and R800 🆕 CPU instructions, being Z80 the default CPU; a `.CPU R800` instruction can be used to enable support for R800 instructions.
The 8080 CPU is not supported by Nestor80. 🚫

The arguments depend on the operator. For CPU instructions they will typically be one or two comma-separated values, each being either a CPU register name or an expression,
for example `LD HL,BUFFER+1000h`. There are operators with mandatory arguments, others with no arguments defined, and others with optional arguments.

Control characters other than tabs are stripped from the source lines before processing, however the form feed characters (encoded as `0xFF` in ASCII and similar encodings)
are counted before these are significant when generating a listing file (they force a listing page change).

MACRO-80 assumes that the source code is encoded in ASCII, Nestor80 however supports source code supplied in any character encoding. ✨

MACRO-80 treats source code characters with the high bit set as line numbers generated by a text editor, this is not the case of Nestor80. 🚫


### Symbols

A _symbol_ is a named 8 or 16 bit value. When assembling relocatable code this value can belong to the absolute, code or data segment or to a COMMON block. Valid characters for symbols are letters (any unicode letter is allowed, not just ASCII letters ✨), digits, and these: `$.?@_`. The first character of a symbol can't be a digit.

Nestor80 treats symbols in a case-insensitive way, e.g. `foo`, `FOO` and `Foo` refer all to the same symbol.

There's in principle no limit for the length of a symbol ✨, but when assembling relocatable code the maximum length for external and public symbols is 6 characters.
This limitation is given by [the format of the LINK-80 relocatable files](RelocatableFileFormat.md). Nestor80 will issue a warning if it finds two or more external symbols that are
different but share the first 6 characters (since these will get their names truncated and thus be actually the same symbol), and will throw an error if the same happens with public symbols.

When writing relocatable code, the following suffixes are allowed for symbols:

* A symbol reference can have the `##` suffix to indicate that it's an _external symbol_ (a symbol that is defined in another relocatable file). This is equivalent to using the `EXTRN` instruction:

```
ld hl,FOO##

;Equivalent to:

EXTRN FOO
ld hl,FOO
```

* A label can be defined with the `::` suffix (instead of just `:`) to indicate that it's a _public symbol_ (a symbol that can be accessed from another relocatable file). This is equivalent to using the `PUBLIC` instruction:

```
FOO::
  ;Some code

;Equivalent to:

PUBLIC FOO
FOO:
  ;Some code
```

### Named constants

A _named constant_ (or just "constant") is a symbol that represents a numeric value and can be used in expressions. There are two types of constants: fixed and redefinible. The value of a _fixed_ constant can't be altered, while the value of a _redefinible_ constant can, by using a new constant definition instruction with the same constant name.

A fixed constant is defined using the following syntax: `<name>[:] EQU <value expression>`. The colon after the constant name is optional ✨ (in Macro80 the colon after the constant name isn't allowed). Example:

```
FOO equ 34
FOO: equ 30+4  ;Allowed since the value is the same

ld a,FOO+6     ;Equivalent to "ld a,40"

FOO equ 89     ;"Symbol already exists" error
```

A redefinible constant is (re)defined using the following syntax: `<name>[:] DEFL <value expression>`. As in the case of the fixed constants, the colon after the constant name is optional ✨. Example:

```
FOO defl 34
ld a,FOO      ;Equivalent to "ld a,34"

FOO: defl 89
ld a,FOO      ;Equivalent to "ld a,89"

FOO defl FOO+1   ;The constant itself can be part of the redefinition expression
ld a,FOO      ;Equivalent to "ld a,90"
```

For compatibility with Macro80 the `ASET` instruction is allowed as an alias for `DEFL`.


Note that `EQU` and `DEFL` can't be mixed for the same constant name:

```
FOO equ 1
FOO defl 2    ;"Symbol already exists" error
```

```
FOO defl 1
FOO equ 2     ;"Symbol already exists" error
```

⚠ You may think that the term "constant" isn't really appropriate for redefinible values. The term "variable", however, has been avoided on purpose to avoid confussion with how the word is normally used in the context of software development, as "value that can change at runtime"; a redefinible constant can have its value changed _at assemble time_, **not** at runtime.

⚠ (🚫?) The Macro80 manual mentions also the instruction `SET` as an additional alias for `DEFL`, but in practice it doesn't work as such: `SET` is only recognized as the Z80 instruction of the same name in Macro80. Nestor80 behaves as Macro80 behaves and not as the Macro80 documentation says, so you can't use `SET` to define constants.


### Numeric constants

Numeric constants can be specified in any [radix](https://en.wikipedia.org/wiki/Radix) from 2 to 16. The default radix is 10 but this can be changed with the `.RADIX` instruction. When the radix is 11 or higher the letters A to F (case insensitive) are used to represents the digits after the 9.

In order to specify a number in a radix different from the default one the following notations can be used
(prefixes and suffixes are case-insensitive):

Notation |  Radix
---------|-----------------
`nnnnB`     | Binary
`nnnnI` 🆕  | Binary
`nnnnD`  |  Decimal
`nnnnM` 🆕  |  Decimal
`nnnnO`  |   Octal
`nnnnQ`  |   Octal
`nnnnH`  |   Hexadecimal
`X'nnnn'`|  Hexadecimal
`#nnnn` 🆕 |   Hexadecimal

<blockquote>
⚠ The <code>B</code> and <code>D</code> suffixes are actually unusable when the default radix is 12 or higher and 14 or higher, respectively. Consider the following example:

    .RADIX 16
    DEFW 1010b,1234d

  You might think that these are the binary number `1010` and the decimal number `1234`, but that's not the case: these are actually the hexadecimal numbers `010B` and `234D`. This behavior is inherited from MACRO-80.

  That's the reason why the new suffixes `I` (b**I**nary) and `M` (deci**M**al) have been introduced in Nestor80.
</blockquote>

⚠ The `#` prefix for hexadecimal numbers has been introduced in Nestor80 for compatibility with other assemblers that 
use the same notation, but in general it's recommended to use the `H` suffix instead since `#` could cause
confusion with the suffix for external symbols, `##`.

A string can be used as equivalent to the numeric constant resulting from encoding it with the current character encoding, with the following rules:

1. The current character encoding must produce at most two bytes for the string (an error will be thrown otherwise).
2. A string that produces two bytes in the current character encoding is interpreted as a big-endian value in `DEFB` instructions, and as a low-endian value elsewhere.
3. An empty string produces no output in a `DEFB` statement, and the value zero everywhere else.

The second rule exists for consistency with how `DEFB` converts strings into bytes in the general case (strings of any length).

The following example listing illustrates how strings are converted to bytes following these rules:

```
                         .STRENC ASCII
  0000                   defb ''
  0000    41             defb 'A'
  0001    42 41          defw 'AB'
  0003    41 42          defb 'AB'
  0005    41 42 43 44    defb 'ABCD'
  0009    00 00          defw ''
  000B    3E 00          ld a,''
  000D    21 00 00       ld hl,''
```

### Strings

Strings are sequences of arbitrary characters enclosed in single quotes, `'`, or double quotes, `"`. Strings are converted to bytes using the current character encoding 🆕 (MACRO-80 didn't have the concept of "character encodings" and simply outputted the string bytes as they were physically stored in the source file).

The _current character encoding_ is the one specified in a `--string-encoding` argument when running Nestor80, and
can also be changed in code with the `.STRENC` instruction. You can run Nestor80 with the `--list-encodings` argument
to see a list of available encodings. The default encoding when none is specified is 7 bit ASCII.

Strings that produce two or less bytes once converted to bytes can be used anywhere a numeric value is expected,
see ["Numeric constants"](#numeric-constants). Strings of any length can be used in the `DEFB` instruction, in this case characters
are converted to bytes sequentially in the order in which they appear in the string. 

Single-quoted strings don't accept escape character with the only exception of `''`, which allows escaping the single quote itself. Example:

```
DEFB 'This ain''t gonna escape much'
```

Double-quoted strings accept escape sequences by default using the `\` character as the sequence initiator 🆕. The following escape sequences are allowed (values are in the ASCII encoding except where otherwise stated):

Sequence | Name | Value
---------|------|--------
\\' | Single quote | 27h
\\" | Double quote | 22h
\\\ | Backslash | 5Ch
\0 | Null  | 00h
\a | Alert | 07h
\b | Backspace | 08h
\f | Form feed | 0Ch
\n | New line | 0Ah
\r | Carriage return | 0Dh
\t | Horizontal tab | 09h
\v | Vertical tab | 0Bh
\x | Arbitrary escape sequence (2 hex digits) | Example: \x12 = 12h
\u | Arbitrary escape sequence (4 hex digits) | Example: \u0012 = 12h<br/>Example: \uABCD = CDh, ABh (in UTF-16)

The support for escape sequences in double-quoted strings can be disabled by using the Nestor80 command line argument `--no-string-escapes` or the instruction `.STRESC OFF` in code. When escape sequences are disabled the double quote
character itself can still be escaped by doubling it:

```
.STRESC OFF
db "The ""escaped"" string"
```

⚠ It's recommended to disable escape sequences when compiling old code that contains strings, since in MACRO-80
the `\` character was considered a regular character with no escaping meaning.
<br/><br/>
⚠ Note that when string escaping is enabled the only way to escape the double quote character is to use the `\"` sequence or the `\u0022` sequence; the special sequence `""` is available only when escape sequences are disabled.

An empty string (e.g. `DEFB ''`) produces no output.


#### Strings in messages for the assembler console

The messages to be printed during the assembly process with the `.PRINT`, `.WARN`, `.ERROR` and `.FATAL` instructions can optionally be enclosed in double quotes, `"`. When that's the case these messages support the same escape sequences that the strings used in expressions, once decoded these will be sent "as is" to the console; also `""` can be used to represent an empty string. For example:

```
.PRINT1 "Hello\nworld"
.PRINT1 ""
.PRINT1 "Printing \"nice\" messages"
```

This is what will get printed:

```
Hello
world

Printing "nice" messages
```

⚠ Escape sequences are always processed as such in messages enclosed in double quotes for `.PRINT`, `.WARN`, `.ERROR` and `.FATAL` instructions, even if escape sequences for regular strings are disabled with `.STRESC OFF` or by passing the `--no-string-escapes` argument to Nestor80.


### Expressions

An _expression_ is a combination of numeric constants, symbols and arithmetic operators that are ultimately evaluated to a numeric value. When assembling relocatable code, expressions that contain external symbol references aren't evaluated; instead, they are outputted to the target relocatable file "as is" to that the evaluation will happen at linking time once the values of all the involved external references have been resolved (see "Writing relocatable code").

If a 8 bit value is expected (e.g. `DB <value>` or `LD A,<value>`) the expression must evaluate to a 16 bit value whose high byte is either 0 or FFh (otherwise an overflow error will be thrown) and the effective value of the expression is the low byte. On the other hand, if a 16 bit value is expected (e.g. `DW <value>` or `LD HL,<value>`) any overflow beyond the lower 16 bits is ignored and the result is the value formed by the low order 16-bits (e.g. `123456h` is interpreted as `3456h`).

Nestor80 defines the following arithmetic operators:

Operator | Meaning | Precedence | Allowed with externals?
---------|---------|------------|------------------------
`NUL`      | Rest of expression<br/> is empty? | 10 | See note
`TYPE`     | Argument type | 9 | See note
`LOW`      | Low byte | 8 | ✔️
`HIGH`     | High byte | 8 | ✔️
`*`        | Multiplication | 7 | ✔️
`/`        | Integer division | 7 | ✔️
`MOD`      | Remaining of<br/>integer division | 7 | ✔️
`SHR`      | Shift right | 7 | ❌
`SHL`      | Shift left | 7 | ❌
`-` (unary) | Unary minus | 6 | ✔️
`+`        | Addition | 5 | ✔️
`-`        | Substraction  | 5 | ✔️
`EQ`       | Equals | 4 | ❌
`=` 🆕    | Equals | 4 | ❌
`NE`       | Not equals | 4 | ❌
`NEQ` 🆕  | Not equals | 4 | ❌
`LT`       | Less than | 4 | ❌
`LE`       | Less than or equal  | 4 | ❌
`LTE` 🆕  | Less than or equal  | 4 | ❌
`GT`       | Greater than | 4 | ❌
`GE`       | Greater than or equal | 4 | ❌
`GTE` 🆕  | Greater than or equal | 4 | ❌
`NOT`      | Bitwise NOT<br/>(one's complement) | 3 | ✔️
`AND`      | Bitwise AND | 2 | ❌
`OR`       | Bitwise OR | 1 | ❌
`XOR`      | Bitwise XOR | 1 | ❌

The `NUL` and `TYPE` operators are special:

* `NUL` works as follows: if the remaining of the source code line after the operator (not including the comment, if present) has any characters other than spaces and tabs, it will evaluate to 0; otherwise it will evaluate to 0FFFFh. This is useful mainly in the context of macro expansions.

* `TYPE` will evaluate to a fixed absolute value depending on the type of the argument passed to it:

Argument type |  Value
--------------|-------
External symbol reference | 0x80
Numeric constant or absolute symbol | 0x20
Symbol defined in the code segment | 0x21
Symbol defined in the data segment | 0x22
Symbol defined in a COMMON block | 0x23

For example `TYPE FOO##` evaluates to 0x80, and `TYPE FOO` evaluates to 0x21 if `FOO` is a label defined in the code segment. Of course, when assembling absolute code `TYPE` will evaluate everything to 0x20.

⚠🚫 The `TYPE` operator is intended to be used with plain symbols and will act weirdly with complex expressions. For example, `TYPE (FOO##+1)` will evaluate to A0h in MACRO-80 and throw an error in Nestor80.

The operator precedence determines how the expression is evaluated: subexpressions involving operators of higher precedence are computed first, and operators with the same precedence are applied in the order in which they appear in the expression. For example, the expression `2+3*4` evaluates to 14 because `*` has higher precedence than `+`. Parenthesis can be used to override the default operator precedence, for example `(2+3)*4` evaluates to 20.

The comparison operators (`GT`, `LT`, `GE`, `LE`, `EQ`, `NE` and equivalents) evaluate to FFFFh if the comparison is true and to zero otherwise. Also they treat the numbers as unsigned integers, this means that an expression like `x lt 0` always evaluates as zero ("false") for any value of `x`. See `IF` for an example of how to test for negative values.

The `HIGH` and `LOW` operators evaluate to the high and low byte of a 16 bit value, respectively; for example `HIGH 1234h` is 12h and `LOW 1234h` is 34h. When applied to relocatable values, the entire 16 bit value is written to the generated relocatable file and the evaluation is performed at linking time; for example if `FOO` is a label defined as address 1234h in the code segment, and the linker is instructed to use address 8511h as the base for the code segment, then `HIGH FOO` will properly evaluate to 97h and `LOW FOO` to 45h in the target program.

When writing relocatable code only a subset of the existing operators can be used in expressions involving external references, this is a limitation given by [the relocatable file format](RelocatableFileFormat.md). Trying to use one of the unsupported operators in such an expression will result in an assembly error.


#### Expression interpolation 🆕

The messages to be printed during the assembly process with the `.PRINT`, `.WARN`, `.ERROR` and `.FATAL` instructions support _expression interpolation_, that is, they can include expressions that will be evaluated and the result printed as part of the message.

To interpolate an expression in an instruction it must be enclosed in `{` and `}`, using the following format:

```
{expression[:radix[size]]}
```

where:

* `radix` specifies the radix to use to print the expression value, and can be one of the following:
  * `D` or `d` for decimal.
  * `B` or `b` for binary.
  * `X` or `H` for hexadecimal with uppercase letters.
  * `x` or `h` for hexadecimal with lowercase letters.

The default radix used if none specified is 10, regardless of any radix set with the `.RADIX` instruction.

* `size` is the minimum number of digits that will be printed. The printed value will be padded to the left with zeros if needed.

For example, the following line

```
.print 20+11 equals {20+11}, or {20+11:H}h, or {20+11:x4}h, or {20+11:b8}b.
```

will print

```
20+11 equals 31, or 1Fh, or 001fh, or 00011111b.
```

⚠ All the symbols included in interpolated expressions must be known when the instruction is processed (this implies that the expressions can't contain external symbol references), otherwise an error will be thrown and the messages will be printed with the "offending" expressions unevaluated. Usually you'll want to use `.PRINT2` instead of `.PRINT` or `.PRINT1` to ensure that.


#### Bare expressions

MACRO-80 allows _bare expressions_ lines, these are lines that have no operand and contain just a list of comma-separated expressions; these lines are treated as `DEFB` instructions. For example the line `1,2,3,4` is equivalent to `DEFB 1,2,3,4`.

In Nestor80 bare expressions aren't supported by default 🚫, but they will be supported if the `--allow-bare-expressions` command line argument is used. You might need this to assemble old source code, but in general bare expressions shouldn't be used since they can cause confussion (for example if you intend to introduce a named macro expansion and mistype the macro name you'll get a confusing "symbol not found" error).


## Advanced features

### Modules ✨

A _module_ is a set of consecutive source code lines grouped under a unique name. All symbols defined inside a module (and by default, also all the non-external referenced symbols) will be considered _relative_ to the module name; this means that the effective symbol name will be `module_name.symbol`. Example:

```
MAIN_INIT:
  call GRAPHICS.init
  call SOUND.init
  ret

module GRAPHICS

init:
  ;Some unique init
initloop:
  ;Some repeated init
  djnz initloop
  ret

endmod

module SOUND

init:
  ;Some unique init
initloop:
  ;Some repeated init
  djnz initloop
  ret

endmod
```

The above code is equivalent to the following one that doesn't use modules:

```
MAIN_INIT:
  call GRAPHICS.init
  call SOUND.init
  ret

GRAPHICS.init:
  ;Some unique init
GRAPHICS.initloop:
  ;Some repeated init
  djnz GRAPHICS.initloop
  ret

SOUND.init:
  ;Some unique init
SOUND.initloop:
  ;Some repeated init
  djnz SOUND.initloop
  ret
```

In order to refer to a symbol defined outside the module there are two options:

1. Prepend the symbol name with a colon, `:`
2. Use the `ROOT` instruction to list the symbols that are to be considered as defined outside the module.

Example:

```
CHPUT equ 00A2h

MAIN_INIT:
  call GRAPHICS.init
  call SOUND.init
  ret

module GRAPHICS

init:
  ld a,'!'
  call :CHPUT
  ret

endmod

module SOUND

root CHPUT

init:
  ld a,'?'
  call CHPUT
  ret

endmod
```

Modules can be nested:

```
MAIN_INIT:
  call GRAPHICS.LOWRES.init
  ret

module GRAPHICS
module LOWRES

init:
  ;Do init
  ret

endmod
endmod
```

When a symbols starts with a dot, no extra dot will be added when concatenating the symbol name and the module name, so `.symbol` becomes `module.symbol`, not `module..symbol`:

```
MAIN_INIT:
  call GRAPHICS.init
  call GRAPHICS..reinit
  ret

module GRAPHICS

.init:
  ;Do init
  ret

..reinit:
  ;Do reinit
  ret

endmod
```


### Relative labels ✨

A _relative label_ is a label that starts with a dot, `.`, and is found after a non-relative label; the former is considered to be relative to the later, that is, the effective label name for `.relative` is `non_relative.relative`:

```
.relab

print:
  ;Init
.loop:
  ;Stuff
  djnz .loop
  ret

update:
  ;Init
.loop:
  ;Stuff
  djnz .loop
  ret
```

The above code is equivalent to the following one that doesn't use relative labels:

```
print:
  ;Init
print.loop:
  ;Stuff
  djnz print.loop
  ret

update:
  ;Init
update.loop:
  ;Stuff
  djnz update.loop
  ret
```

⚠ Relative labels are disabled by default. To enable the feature the `.RELAB` instruction must be used; conversely, the `.XRELAB` instruction disables the feature.

Within expressions any symbol whose name starts with a dot will be considered a relative label if the feature is enabled and at least one non-relative label has been declared previously, this can lead to errors when referencing constants:

```
.relab

.STROUT equ 09h

FOO:
  ;Do stuff
  ret

ld a,.STROUT  ;Error: symbol "FOO.STROUT" not found
```

In order to reference a symbol whose name starts with a dot but is not a relative label there are two options:

1. Prepend the symbol name with a colon, `:`
2. Temporarily disable the relative labels with `.XRELAB`

Example:

```
.relab

.STROUT equ 09h
BDOS equ 0005h

print:
  ld c,:.STROUT
  call BDOS
  ret	

reprint:
  .xrelab
  ld c,.STROUT
  .relab
  call BDOS
  ret
```

The last non-relative symbol is forgotten (and thus symbols starting with a dot go back to being considered regular symbols) when:

1. A module is entered (`MODULE` instruction) or exited (`ENDMOD` instruction).
2. The feature is enabled with `.RELAB` or disabled with `.XRELAB` (even if it was already enabled or disabled).

Example:


```
.relab

.STROUT equ 09h

FOO:
  ;Do stuff
  ret

.relab

ld a,.STROUT  ;No error, really referencing ".STROUT" due to the second .relab
```


## Assembler instructions reference

This section lists all the assembler instructions supported by Nestor80. Any instruction alias is listed together with the "canonical" instruction name.

® Additionally to the document-wide icons, an "R" symbol next to an instruction name means that the instruction is relevant only when writing relocatable code. If you only write code intended to be assembled as absolute you can skip the documentation for these instructions. See "Absolute and relocatable code".

Instruction arguments are specified using the standard notation `<name>`. A few instructions require an argument to be passed surrounded by literal angle brackets, in these cases thes angle brackets are specified as `"<"` and `">"`, see for example `IFB`.


### .COMMENT

_Syntax:_ `.COMMENT <delimiter><text><delimiter>`

Defines a block of comment text with support for multiple lines. The first character found after the instruction will be considered the delimiter, and all text found in the source code until the delimiter is found again will be considered a comment and not processed. Example:

```
.COMMENT * Here we go!

This is a comment, anything until another asterisk is found is ignored.

*

ld a,34 ;Regular code again
```

The entire line where the closing delimiter is found will be considered as part of the comment and thus ignored:

```
.COMMENT *

Blah blah

* This is still ignored!

ld a,34 ;Regular code again
```


### .CPU 🆕

_Syntax:_ `.CPU <cpu name>`

Changes the target CPU for the assembled code. 

Currently the supported CPUs are `Z80` (default) and `R800`. The only difference is that setting the R800 as the target CPU enables the `MULUB` and `MULUW` instructions:

```
MULUB A,A
MULUB A,B
MULUB A,C
MULUB A,D
MULUB A,E
MULUB A,H
MULUB A,L
MULUW HL,BC
MULUW HL,DE
MULUW HL,HL
MULUW HL,SP
```

[The Z80 undocumented instructions](http://www.z80.info/z80undoc.htm) are always supported.


### .CREF 🚫

_Syntax:_ `.CREF` 

In Macro80 this instruction enabled the inclusion of cross-reference information when generating a listing file. Nestor80 doesn't implement cross-reference information generation and thus this instruction does nothing.


### .DEPHASE

_Syntax:_ `.DEPHASE`

Marks the end of a phased code block. See `.PHASE`.


### .ERROR 🆕

_Syntax:_ `.ERROR ["]<text>["]`

Emits an assembly error with the specified text. The text supports expression interpolation.

When one or more errors are emitted in pass 1, pass 2 will be skipped. See "Passes", "Strings in messages for the assembler console".


### .FATAL 🆕

_Syntax:_ `.FATAL ["]<text>["]`

Throws an fatal error with the specified text. The text supports expression interpolation.

A fatal error will terminate the assembly process immediately. See also "Strings in messages for the assembler console".


### .LALL

_Syntax:_ `.LALL`

Instructs Nestor80 to include the complete macro text for expanded macros in listings following the instruction. The default initial condition (also set by `.XALL`) is to include only the source lines that produce any output in the target file (assembler instructions and `DEFB`, `DEFW` etc). See `.XALL`, `.SALL`, "Macros", "Listings".


### .LFCOND

_Syntax:_ `.LFCOND`

Instructs Nestor80 to include conditional blocks that evaluate as false in listings for all the matching blocks following the instruction. This is the default initial condition unless a `--no-listing-false-conditionals` argument is supplied to Nestor80. See also `.LFCOND`, `.TFCOND`, "Conditional blocks", "Listings".


### .LIST

_Syntax:_ `.LIST`

Instructs Nestor80 to include all the source code text following the instruction. This is the default initial condition when Nestor80 is instructed to generate a listing file with the `--listing` argument. See also `.XLIST`, "Listings".


### .PHASE

_Syntax:_ `.PHASE <address>`

Starts a phased code block. A _phased code block_ is a set of instructions that are intended to be run at a different memory address (indicated by the `<address>` argument) than the one dictated by the current location pointer. `.DEPHASE` is used to mark the end of a phased code block.

For example, assume that you have the following code in ROM starting at address 4000h and you have RAM starting at address 8000h. Your ROM is banked, with the bank number selected via Z80 port 10h. This is the code that you could use to calculate the 1 byte checksum of a given bank, together with the addresses and output generated for reference:

```
8000                  RAM_BUFFER equ 8000h
                    
                      org 4000h
                    
4000    21 13 40      ld hl,CALCULATE_CHECKSUM
4003    11 00 80      ld de,8000h
4006    01 1A 00      ld bc,CALCULATE_CHECKSUM_END - CALCULATE_CHECKSUM
4009    ED B0         ldir
                    
400B    3E 01         ld a,1
400D    CD 00 80      call RAM_BUFFER
4010    C3 2D 40      jp MORE_CODE
                    
                    ;Calculate the 1-byte checksum of a ROM bank.
                    ;Input:  A = ROM bank number
                    ;Output: A = Checksum
4013                CALCULATE_CHECKSUM:
                      .phase RAM_BUFFER
                    
8000    D3 10         out (10h),a
8002    16 00         ld d,0
8004    21 00 40      ld hl,4000h
8007    01 00 40      ld bc,4000h
                    
800A                LOOP:
800A    7E            ld a,(hl)
800B    82            add a,d
800C    57            ld d,a
800D    23            inc hl
800E    0B            dec bc
800F    78            ld a,b
8010    B1            or c
8011    C2 0A 80      jp nz,LOOP
                    
8014    3E 00         ld a,0
8016    D3 10         out (10h),a  ;Assume the ROM bank number of the caller was 0
                    
8018    7A            ld a,d
8019    C9            ret
                    
                      .dephase
402D                CALCULATE_CHECKSUM_END:
                    
                      ;Location counter from before .PHASE is restored here,
                      ;appropriately updated by the size of the phased block
402D                MORE_CODE:
402D    3E 22         ld a,34
```

Although the starting address of a phased block will normally be an absolute address, using relocatable addresses is also allowed:

```
0000'                 dseg
                      org 1000h
1000"               FOO:
                  
1000"                 cseg
                  
0000'   3E 22         ld a,34
                  
                      .phase FOO
1000"   00 01 02      db 0,1,2
                      .dephase
                  
0005'   3E 59         ld a,89
```

🚫 There are two restrictions for phased blocks that weren't present in Macro80:

1. The value of `<address>` must be known by the time the `.PHASE` statement is reached (it can't be an expression containing a symbol that is defined later in code).
2. Segment change instructions (`ASEG`, `CSEG`, `DSEG`, `COMMON`) aren't allowed inside a phased block.

The second one is something that doesn't seem to be supported by Macro80 anyway: even though no errors are emitted, the location counter gets an incorrect value after a segment change instruction inside a phased block.


### .PRINT 🆕

_Syntax:_ `.PRINT ["]<text>["]`

Prints a text to the terminal where the assembler is running (unless the `--silence-assembly-print` argument was passed to Nestor80). The message supports expression interpolation.

The text will be printed in both pass 1 and pass 2. Normally you'll want to print the text only in one of the passes, so you should either wrap the `.PRINT` instruction in an `IF1` or `IF2` block, or use the `.PRINT1` or `.PRINT2` instruction instead. See "Passes", "Strings in messages for the assembler console".


### .PRINT1 🆕

_Syntax:_ `.PRINT1 ["]<text>["]`

Like `.PRINT`, but only prints the text in pass 1. See "Passes", "Strings in messages for the assembler console".


### .PRINT2 🆕

_Syntax:_ `.PRINT1 ["]<text>["]`

Like `.PRINT`, but only prints the text in pass 2. See "Passes", "Strings in messages for the assembler console".


### .PRINTX

_Syntax:_ `.PRINTX <delimiter><text>[<delimiter>]`

Prints a text to the terminal where the assembler is running (unless the `--silence-assembly-print` argument was passed to Nestor80). The first character of the text is considered a delimiter, and the text is printed until either the delimiter is found again or the end of the line is found (the delimiters themselves are printed too). For example `.PRINTX /Foo` prints `/Foo`, and `.PRINTX /Foo/bar` prints `/Foo/`.

This instruction is provided for compatibility with Macro80. New programs should use `.PRINT`, `.PRINT1` or `.PRINT2` instead, which don't need a delimiter and support expression interpolation and escape sequences in the text.


### .RADIX

_Syntax:_ `.RADIX <value>`

Changes the default radix for the numeric constants that don't have a radix suffix. `<value>` must evaluate to a number between 2 and 16, and the default radix for numeric constants in `<value>` is 10 regardless of the current default radix.

Example:

```
db 12      ;12

.radix 16
db 12      ;18

.radix 2
db 1010    ;10
```


### .RELAB 🆕

_Syntax:_ `.RELAB`

Enables the relative labels feature. See also `.XRELAB`.


### .REQUEST ®

_Syntax:_ `.REQUEST <filename>[,<filename>[,...]]`

Defines a list of files in which the linker will search for any globals that remain undefined during the linking process. For compatibility with Link80 filenames must be up to 7 characters long, contain only ASCII letters, and can't contain an extension (`.REL` extension is assumed) nor any drive or directory specification.


### .SALL

_Syntax:_ `.SALL`

Instructs Nestor80 to not include macro expansions in listings following the instruction. The default initial condition (also set by `.XALL`) is to include only the source lines that produce any output in the target file (assembler instructions and `DEFB`, `DEFW` etc). See `.XALL`, `.LALL`, "Macros", "Listings".


### .SFCOND

_Syntax:_ `.SFCOND`

Instructs Nestor80 to **not** include conditional blocks that evaluate as false in listings for all the matching blocks following the instruction. See also `.LFCOND`, `.TFCOND`, "Conditional blocks", "Listings".


### .STRENC 🆕

_Syntax:_ `.STRENC <encoding name>|<encoding page>|default`

Sets the character encoding to be used to transform strings to sequences of bytes, typically for the `DEFB` insruction.

The encoding name or page must be one of the encodings supported by the system where Nestor80 is running. Running Nestor80 with the `--list-encodings` argument will show a list of the available encodings; each encoding has an unique name and an unique page number and either of the two can be used to identify the encoding.

The default encoding is 7 bit ASCII unless a different encoding is specified by passing a `--string-encoding` argument to Nestor80. `.STRENC default` will revert to this default encoding.

The encoding name `ASCII` is accepted as an alias for the default 7 bit ASCII encoding (whose "official" name is `US-ASCII`).

See also: "Strings".


### .STRESC 🆕

_Syntax:_ `.STRESC ON|OFF`

Turns on or off the support for escape sequences in strings delimited by double quotes, `"`. Escape sequences are enabled by default unless a `--no-string-escapes` argument is passed to Nestor80.

Turning off escape sequences may be needed when compiling old source code intended for Macro80 in which the backslash character `\` is considered a regular character and not an escape sequence initiator. New programs should leave string escaping turned on and take advantage of the escape sequence support as needed.

See "Strings" for a list of the available escape sequences.


### .TFCOND

_Syntax:_ `.TFCOND`

Instructs Nestor80 to toggle the inclusion of conditional blocks that evaluate as false in listings, from on to off or the other way around, for all the matching blocks following the instruction. 

The state that gets toggled is the one that was set by the previous instance of `.TFCOND` (any state change performed with `.LFCOND` or `.SFCOND` is ignored). The initial state is "on" unless a `--no-listing-false-conditionals` argument is passed to Nestor80.

See also `.LFCOND`, `.SFCOND`, "Conditional blocks", "Listings".


### .WARN 🆕

_Syntax:_ `.WARN ["]<text>["]`

Emits an assembly warning with the specified text. The text supports expression interpolation.

The warning will be emitted twice, once in pass 1 and once in pass2. If that's undesirable you can enclose the instruction in an `IF1` or `IF2` block. See "Passes", "Strings in messages for the assembler console".


### .XALL

_Syntax:_ `.XALL`

Instructs Nestor80 to include macro expansions in listings following the instruction, but only including the source lines that produce any output in the target file (assembler instructions and `DEFB`, `DEFW` etc); this is the default state for macro expansions in listings. See `.XALL`, `.LALL`, "Macros", "Listings".


### .XCREF "🚫"

_Syntax:_ `.XCREF` 

In Macro80 this instruction disabled the inclusion of cross-reference information when generating a listing file (which had been enabled with `.CREF`). Nestor80 doesn't implement cross-reference information generation and thus this instruction is a no-op.


### .XLIST

_Syntax:_ `.XLIST`

Instructs Nestor80 to suppress the inclusion in listings of the source code text that follows the instruction, until either the end of the file (or an `END` instruction) is reached or a `.LIST` instruction is encountered. See also "Listings".


### .XRELAB 🆕

_Syntax:_ `.XRELAB`

Disables the relative labels feature. See also `.RELAB`.


### .Z80

_Syntax:_ `.Z80`

Sets the Z80 as the current target CPU. This instruction is provided for compatibility with Macro80, new programs should use `.CPU Z80` instead.


### ASEG ®

_Syntax:_ `ASEG`

Switches to the absolute segment and sets the location counter to the value it had the last time that segment was switched off with `CSEG`, `DSEG` or `COMMON` (or to zero, if it's the first time this instruction is used).

Example:

```
ASEG
;Location counter here: absolute segment 0000h

org 100h
db 1,2,3,4
;Location counter here: absolute segment 0104h

CSEG
db 10,20,30,40
DSEG
db 50,60,70,80

ASEG
;Location counter here: absolute segment 0104h
```


### COMMON ®

_Syntax:_ `COMMON /[<name>]/`

Switches to the COMMON block of the specified name and sets the location counter to zero (**not** to the last known location counter value for the block, this behavior is compatible with Macro80). The COMMON block name must be enclosed in two `/` characters (that aren't part of the name), is case-insensitive, and can be empty.

Example:

```
COMMON /foo/
;Location counter here: COMMON FOO 0000h

org 100h
db 1,2,3,4
;Location counter here: COMMON FOO 0104h

COMMON //
;Location counter here: COMMON (empty) 0000h

COMMON /FOO/
;Location counter here: COMMON FOO 0000h
```


### CONTM 🆕

_Syntax:_ `CONTM`

This instruction is intended to be used inside macro definitions. In named macro expansions it's equivalent to `.EXITM`, in repeat macros it exits the current repetition immediately and then starts over at the next repetition (if there are more repetitions remaining), unlike `.EXITM` which discards any remaining repetition.

Example:

```
rept 3
db 1
db 2
contm
db 3
db 4
endm

;Generated code:

db 1
db 2
db 1
db 2
db 1
db 2
```


### CSEG ®

_Syntax:_ `CSEG`

Switches to the code segment and sets the location counter to the value it had the last time that segment was switched off with `CESG`, `DSEG` or `COMMON`. The code segment is switched on with the location counter set to zero at the start of the source code processing.

Example:

```
;Location counter here: code segment 0000h

org 100h
db 1,2,3,4
;Location counter here: code segment 0104h

ASEG
db 10,20,30,40
DSEG
db 50,60,70,80

CSEG
;Location counter here: code segment 0104h
```


### DEFB (DB, DEFM)

_Syntax:_ `DEFB <expression or string>[,<expression or string>[,...]]`

_Aliases:_ `DB`, `DEFM`

Defines a sequence of or more raw bytes to be included in the output. Each item must be either an expression that can be evaluated to a byte, or a string; strings are converted to sequences of bytes using the current character encoding.

Example:

```
FOO equ 10h

.STRENC ASCII
DEFB 0FF34h,FOO*2,"ABC\r\n"

;Sequence of bytes generated:
;34h,20h,41h,42h,43h,0Dh,0Ah
```

See also: "Expressions", "Strings".


### DEFS (DS)

_Syntax:_ `DEFS <size>[,<value>]`

_Aliases:_ `DS`

Defines a block of contiguous memory addresses of a given size, to be optionally filled with a repeated byte value.

Example with `<value>` specified:

```
DEFS 5,34

;Equivalent to:

DEFB 34,34,34,34,34
```

When `<value>` is not specified the output depends on the build type:

* When the build type is absolute, `DEFB <size>` is equivalent to `DEFB <size>,0`.
* When the build type is relocatable, by default `DEFB <size>` will generate an output equivalent to `ORG $+<size>`; that is, the location counter will be increased by the specified size and the block will be considered by the linker as a "memory gap" (how memory gaps are filled at linking time is undefined).
* When the build type is relocatable and a `--initialize-defs` argument is supplied to Nestor80, `DEFB <size>` is equivalent to `DEFB <size>,0`.

See also "Absolute and relocatable code".


### DEFW (DW)

_Syntax:_ `DEFW <expression or string>[,<expression or string>[,...]]`

_Aliases:_ `DW`

Defines a sequence of or more raw _words_ (16 bit values) to be included in the output. Each item must be either an expression, or a string that gets converted to at most two bytes using the current character encoding. Expression values are stored in little endian format, and strings are stored as the second byte (of the output generated by the character encoding) first, then the first byte.

Example:

```
FOO equ 1200h

.STRENC ASCII
DEFW 7,0ABCDh,FOO+34h,"A","BC"

;Sequence of bytes generated:
;07h,00h,CDh,ABh,34h,12h,41h,00h,43h,42h
```

See also: "Expressions", "Strings".


### DEFZ (DZ) 🆕

_Syntax:_ `DEFZ <expression or string>[,<expression or string>[,...]]`

_Aliases:_ `DZ`

This instruction is equivalent to `.DEFB`, but appends the bytes that the current character encoding generates for the character `\0` at the end of the generated sequence of bytes. This is useful to define zero-terminated strings without having to explicitly specify the zero character.

Example:

```
.STRENC ASCII
DEFZ "Hello"

;Equivalent to:

DEFB "Hello\0"

;...and to:

DEFB "Hello",0
```


### DSEG ®

_Syntax:_ `DSEG`

Switches to the data segment and sets the location counter to the value it had the last time that segment was switched off with `CSEG`, `ASEG` or `COMMON` (or to zero, if it's the first time this instruction is used).

Example:

```
DSEG
;Location counter here: data segment 0000h

org 100h
db 1,2,3,4
;Location counter here: data segment 0104h

CSEG
db 10,20,30,40
ASEG
db 50,60,70,80

DSEG
;Location counter here: data segment 0104h
```


### ELSE

_Syntax:_ `ELSE`

Ends the main condition block of a conditional assembly block and starts the opposite condition block. See "Conditional assembly".


### END

_Syntax:_ `END [<address>]`

Ends the assembly process immediately, ignoring any source code remaining in the file.

The optional `<address>` argument is significant only when writing relocatable code, this address will be stored in the relocatable file as the program start address and it's up to the linker to use it during the linking process.


### ENDIF

_Syntax:_ `ENDIF`

Ends a conditional assembly block. See "Conditional assembly".


### ENDM

_Syntax:_ `ENDM`

Ends a macro definition, and for repeat macros it starts the macro expansion. See "Macros".


### ENDMOD

_Syntax:_ `ENDMOD`

Ends the current module. See "Modules".


### ENDOUT 🆕

_Syntax:_ `ENDOUT`

Instructs Nestor80 to stop generating output immediately while continuing to process the source code that follows the instruction (thus taking note of symbol definitions). This is useful as an alternative to constant definitions to define memory areas that don't need to be explicitly included in the output file.

Example:

```
org 100h

BUFFER_SIZE: equ 1024

ld hl,BUFFER
ld de,BUFFER+1
ld bc,BUFFER_SIZE-1
ld (hl),0
ldir

ld hl,1234h
ld (FLAGS),hl
ld a,89h
ld (FLAGS2),hl

ret

endout

org 8000h
BUFFER: ds BUFFER_SIZE
FLAGS: dw 0
FLAGS2:
```

Equivalent code without using `ENDOUT`:

```
org 100h

BUFFER_SIZE: equ 1024
BUFFER: equ 8000h
FLAGS: equ BUFFER+BUFFER_SIZE
FLAGS2: equ FLAGS+2

ld hl,BUFFER
ld de,BUFFER+1
ld bc,BUFFER_SIZE-1
ld (hl),0
ldir

ld hl,1234h
ld (FLAGS),hl
ld a,89h
ld (FLAGS2),hl

ret
```


### EXITM

_Syntax:_ `EXITM`

This instruction is intended to be used inside macro definitions. It forces the macro expansion to terminate immediately, discarding any remaining repetition (unlike `CONTM` which starts over the next repetition, if any). See "Macros"

Example:

```
rept 3
db 1
db 2
exitm
db 3
db 4
endm

;Generated code:

db 1
db 2
```


### EXTRN (EXT, EXTERNAL) ®

_Syntax:_ `EXTRN <symbol>[,<symbol>[,...]]`

_Aliases:_ `EXT`, `EXTERNAL`

Defines one or more symbol names as external, that is, they are supposed to be defined as public symbols by another relocatable program during the linking process. A symbol is also considered external if its name is followed by `##` when it's referenced:

```
call FOO##

;Equivalent to:

EXTRN FOO
call FOO
```


### IF (IFT, COND)

_Syntax:_ `IF <expression>`

_Aliases:_ `IFT`, `COND`

Starts a conditional assembly block in which the true condition is that `<expression>` evaluates to non-zero. The opposite instruction is `IFF`.

This instruction is typically used in macros and in combination with comparison operators. Example:

```
is_positive macro x

if (x) eq 0
  .print1 '&x' is zero
else
  if ((x) and 8000h) eq 8000h
    .print1 '&x' is negative
  else
    .print1 '&x' is positive
  endif
endif

endm

is_positive 1+1
is_positive 1-1
is_positive 1-2
```

This is what gets printed:

```
'1+1' is positive
'1-1' is zero
'1-2' is negative
```

⚠ You may be wondering why the previous example doesn't use `if (x) gt 0` or `if (x) lt 0` for the positive and negative cases. Nestor80 treats all numbers as unsigned integers, and thus `if (x) lt 0` is never true. This behavior is compatible with MACRO-80.

See "Expressions", "Macros", "Conditional assembly".


### IF1

_Syntax:_ `IF1`

Starts a conditional assembly block in which the true condition is that the assembler is currently in pass 1. See "Passes", "Conditional assembly".


### IF2

_Syntax:_ `IF2`

Starts a conditional assembly block in which the true condition is that the assembler is currently in pass 2. See "Passes", "Conditional assembly".


### IFABS 🆕

_Syntax:_ `IFABS`

Starts a conditional assembly block in which the true condition is that the build type is absolute. The opposite instruction is `IFREL`. See "Absolute and relocatable code", "Conditional assembly".


### IFB

_Syntax:_ `IFB "<"<text>">"`

Starts a conditional assembly block in which the true condition is that `<text>` is blank (has a zero length, including spaces). `<text>` must be surrounderd by angle brackets. The opposite instruction is `IFNB`.

`IFB` is typically used in macros in order to detect if a given argument is supplied. Example:

```
FOO macro x,y

ifb <x>
.error FOO: First argument is required!
endif

ifb <y>
.print FOO: No second argument passed.
else
.print FOO: Second argument passed: y
endif

endm
```

See "Conditional assembly", "Macros".


### IFCPU 🆕

_Syntax:_ `IFCPU <cpu name>`

Starts a conditional assembly block in which the true condition is that the current CPU is the one specified. The opposite instruction is `IFNCPU`. Example:

```
ifcpu R800
MULUW HL,BC
else
call MULUW_HL_BC
endif
```

⚠ A non-existing CPU name passed as argument will evaluate to false and not throw any error.


### IFDEF

_Syntax:_ `IFDEF <symbol>`

Starts a conditional assembly block in which the true condition is that `<symbol>` is defined when the instruction is encountered. This may be useful in combination with the `--define-symbols` Nestor80 argument to externally alter how the code is assembled. The opposite instruction is `IFNDEF`.

⚠ Keep in mind that a symbol that gets defined in code is undefined before it's found in pass 1, but it's already defined when pass 2 starts:

```
.print2 Pass 2 started!

.print Before EQU...

ifdef foo
.print1 "Foo" is defined in pass 1
.print2 "Foo" is defined in pass 2
else
.print1 "Foo" is NOT defined in pass 1
.print2 "Foo" is NOT defined in pass 2

endif

foo equ 1

.print After EQU...

ifdef foo
.print1 "Foo" is defined in pass 1
.print2 "Foo" is defined in pass 2
else
.print1 "Foo" is NOT defined in pass 1
.print2 "Foo" is NOT defined in pass 2
endif
```

This is what gets printed:

```
Before EQU...
"Foo" is NOT defined in pass 1
After EQU...
"Foo" is defined in pass 1
Pass 2 started!
Before EQU...
"Foo" is defined in pass 2
After EQU...
"Foo" is defined in pass 2
```

See "Passes", "Conditional assembly".


### IFDIF

_Syntax:_ `IFDIF "<"<text1>">","<"<text2>">"`

This instruction is the opposite of `IFIDN`: the true condition is that `<text1>` is **not** identical to `<text2>`, including any spaces.

See "Conditional assembly".


### IFDIFI 🆕

_Syntax:_ `IFDIFI "<"<text1>">","<"<text2>">"`

This instruction is the opposite of `IFIDNI`: the true condition is that `<text1>` is **not** identical to `<text2>`, including any spaces, with the comparison being done in a case-insensitive way.

See "Conditional assembly".


### IFF (IFE)

_Syntax:_ `IFF <expression>`

_Aliases:_ `IFE`

This instruction is the opposite of `IF`: the true condition is that `<expression>` evaluates to zero.

See "Conditional assembly".


### IFIDN

_Syntax:_ `IFIDN "<"<text1>">","<"<text2>">"`

Starts a conditional assembly block in which the true condition is that `<text1>` is identical to `<text2>`, including any spaces. The texts must be surrounderd by angle brackets. The opposite instruction is `IFDIFF`.

Example:

```
compare macro x,y

ifidn <x>,<y>
.print1 '&x' is identical to '&y'
else
.print1 '&x' is NOT identical to '&y'
endif

endm

compare foo,bar
compare foo,foo
compare foo,FOO
```

This is what gets printed:

```
'foo' is NOT identical to 'bar'
'foo' is identical to 'foo'
'foo' is NOT identical to 'FOO'
```

See "Conditional assembly".


### IFIDNI 🆕

_Syntax:_ `IFIDNI "<"<text1>">","<"<text2>">"`

This instruction is equivalent to `IFIDN`, except that the comparison of `<text1>` and `<text2>` is done in a case-insensitive way. The opposite instruction is `IFDIFFI`.

Example:

```
compare macro x,y

ifidni <x>,<y>
.print1 '&x' is case-insensitive identical to '&y'
else
.print1 '&x' is NOT case-insensitive identical to '&y'
endif

endm

compare foo,bar
compare foo,foo
compare foo,FOO
```

This is what gets printed:

```
'foo' is NOT case-insensitive identical to 'bar'
'foo' is case-insensitive identical to 'foo'
'foo' is case-insensitive identical to 'FOO'
```

See "Conditional assembly".


### IFNB

_Syntax:_ `IFNB "<"<text>">"`

This instruction is the opposite of `IFB`: the true condition is that `<text>` is **not** blank (it has a non-zero length, including spaces).

See "Conditional assembly".


### IFNCPU

_Syntax:_ `IFNCPU <cpu name>`

This instruction is the opposite of `IFCPU`: the true condition is that the current CPU is **not** the specified one.

⚠ A non-existing CPU name passed as argument will evaluate to true and not throw any error.

See "Conditional assembly".


### IFNDEF

_Syntax:_ `IFNDEF <symbol>`

This instruction is the opposite of `IFDEF`: the true condition is that the symbol is **not** defined when the instruction is encountered.

See "Conditional assembly".


### IFREL 🆕 ®

_Syntax:_ `IFREL <symbol>`

This instruction is the opposite of `IFABS`: the true condition is that the build type is relative. See "Absolute and relocatable code", "Conditional assembly".


### PAGE (SUBPAGE 🆕, $EJECT)

_Syntax:_ `PAGE <page size>`

_Aliases:_ `SUBPAGE`, `$EJECT`



IF, COND
ENDIF, ENDC
PUBLIC, ENTRY, GLOBAL

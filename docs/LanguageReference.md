# Nestor80 assembler language reference

This documents details the source file format supported by Nestor80 and lists all the available assembler instructions (called "pseudo-operators" in the MACRO-80 manual), both the ones inherited from MACRO-80 and the ones newly introduced by Nestor80.


## Document conventions

The following icons are used in this document:

üÜï A "new" icon is used when introducing a feature or instruction that is new in Nestor80 (it wasn't available in MACRO-80).

‚ú® A "sparks" icon is used when referring to a feature or instruction that was already available in MACRO-80 but has been enhanced or improved in a backwards-compatible way in Nestor80.

üö´ A "forbidden" icon is used to refer to a MACRO-80 feature or instruction that is not available or has changed in a backwards-incompatible way in Nestor80. Old source code intended for MACRO-80 and relying in such features or instructions will likely require changes before being suitable for assembly with Nestor80.

‚ö† A "warning" icon is used when discussing a tricky, subtle or confusing subject; or in general to bring attention to an important concept.

Text in _italics_ will be used the first time a new term or concept is introduced. Alternatively, when a concept or term that is introduced in a later section is used, it will link to the defining section.


## Basic concepts

Before detailing the assembler language reference a couple of concepts related to how the assembler works will be introduced.


### Passes

Nestor80 is a _two pass assembler_. This means that the source code is processed twice: the first time the assembler determines how many bytes each source code line will use in the _target program_ (the contents of the binary file resulting from processing the source code) and updates the current _location counter_ (the pointer in Z80 memory where the code generated by each line will be loaded) accordingly, using this information to assign the appropriate values to labels. The second time, already with all the label values at hand, is when the code is actually assembled.

Let's see a simple example:

```
org 100h
call PROGRAM
ret
PROGRAM:
;Some code here
RET
```

In pass 1 the assembler does the following:

1. It sees a `CALL PROGRAM` instruction and although the value of `PROGRAM` is still unknown, one thing that is for sure is that the line will use three bytes of memory in the target program. Thus, the current location counter is updated to 103h.
2. It sees a `RET` instruction and knows that it will use one byte, thus the location counter is updated to 104h.
3. It sees the definition of the `PROGRAM` label and assigns it the value of the current location counter, 104h.
4. It processes the rest of the code accordingly.

In pass 2 the assembler already knows the value of `PROGRAM` and thus processes the second line as if it was `CALL 0104h`, writing `CDh 04h 01h` to the target program.

A similar processing happens for other types of symbols that don't depend on the location counter but may be unknown when found in pass 1, e.g. constants:

```
call CHPUT
ret
CHPUT equ 00A2h
```

Usually the fact that the assembly process takes two passes is transparent for the developer, but the `IF1` and `IF2` instructions exist for advanced scenarios in which it's convenient to process different blocks of source code depending on the current pass. This is typically used to prevent the output of duplicated messages during the assembly process with `.PRINT`, `.WARN` or `.ERR`.

Here's an advanced example from the source code of [Nextor](https://github.com/Nextor). The following macro will store the value of a given symbol, but if the symbol is undefined by the time the macro is expanded in pass 2, it will be specified as an external symbol reference (with the `##` suffix); the `DEFW 0` in pass 1 is needed to keep the location counter consistent in both passes:

```
DEFA MACRO ADDR
 IF1
  DEFW	0
 ELSE
  IFDEF	ADDR
   DEFW	ADDR
  ELSE
   DEFW	ADDR##
  ENDIF
 ENDIF
ENDM
```

‚ö† Unlike MACRO-80, Nestor80 will skip pass 2 if errors are found in pass 1  (but not if only warnings are found). Thus during the development process it's possible to find that some assembly errors seemingly "appear from nowhere" after some other errors were fixed (the former being errors found in pass 2 and the later being errors found in pass 1).


### Absolute and relocatable code

Nestor80 can produce both absolute üÜï and relocatable files.

* An _absolute file_ contains code "ready to use", intended to be loaded and executed at the fixed memory locations indicated by the `ORG` instructions found in code (or begninning at address 0, if no such instructions are provided). Most assemblers produce only absolute files.

* _Relocatable files_ have [a dedicated format](RelocatableFileFormat.md) and contain relocatable code, that is, "pre-assembled" code in which labels are flagged as being relative to the memory address where the target program will be loaded and symbols may be flagged as _external_, that is, defined in other relocatable file.

Relocatable files can't be executed, instead a linker (typically LINK-80) must be used to convert it into an absolute file by providing the actual loading memory addresses for the target program. The linker is typically used to "glue together" two or more of these files (and linking public symbols with the corresponding external symbols).

It's possible to instruct Nestor80 to produce an absolute file or a relocatable file by using the `--build-type` command line argument, but by default Nestor80 will decide the appropriate type automatically. The decision is taken as follows:

> If an `ORG` instruction is found in the source code before a CPU instruction, a label defined as public with  `::`, or any of the following instructions: `CSEG`, `DSEG`, `COMMON`, `DEFB`, `DEFW`, `DEFS`, `DC`, `DEFZ`, `PUBLIC`, `EXTRN`, `.REQUEST`, then the build type will be absolute; otherwise the build type will be relocatable.

Put it another way, if you want your code to be automatically detected as intended to be assembled as absolute, use an `ORG` instruction as the first "effective" source code line (so the first line except blanks, comments, macro definitions and constant definitions).

‚ö† If the build type is forced to absolute with `--build-type` but the code contains no `ORG` instructions, an implicit `ORG 0` at the beginning of the code is assumed.

Some assembler instructions make sense only in the context of relocatable code, for example `CSEG`, `DSEG`, `PUBLIC` OR `EXTRN`; these instructions will do nothing, and the assembler will throw warnings, if they are found while assembling absolute code. 

See "Writing relocatable code" for more details about how relocatable code programming works.


## Source code format

Nestor80 converts source code files to absolute or relocatable files. A source code file is a text file in which each line is either blank, a _comment_, or a _statement_; lines
are processed one by one. The maximum supported line length is 1034 characters ‚ú® and all the usual line ending conventions are supported (CR+LF characters, LF only, and CR only). ‚ú® 
Spaces and tabs are treated equivalently, and those found at the beginning and at the end of the line are removed before the line is processed.

A comment-only line starts with a semicolon character, `;`,  and has no effect in the assembly process. A statement has the following format:

```
[label:[:]] [operator] [arguments] [;comment]
```

Any number of spaces or tabs can be used to separate the statement components.

A _label_ is a type of symbol that has the value of the location counter at the time it's defined (the value that the location counter has when the line is processed).
A label definition must end with either `:` or `::`; the later is used when assembling relocatable code to indicate that the label is public.

An _operator_ is a word that can be either the mnemonic of a CPU instruction (e.g. `LD`) or an assembler instruction. An _assembler instruction_ (called "pseudo-operator"
in the MACRO-80 manual) is an instruction for the assembler itself, for example `ORG` instructs the assembler to change the value of the current location counter.

> ‚ö† In this manual the word "instruction" alone will be used to refer to assembler instructions, as opposed to CPU instructions.

The comment, if present, runs until the end of the line and has no effect in the assembly process. Multiline comments are supported by using the `.COMMENT` instruction.

Nestor80 supports Z80 and R800 üÜï CPU instructions, being Z80 the default CPU; a `.CPU R800` instruction can be used to enable support for R800 instructions.
The 8080 CPU is not supported by Nestor80. üö´

The arguments depend on the operator. For CPU instructions they will typically be one or two comma-separated values, each being either a CPU register name or an expression,
for example `LD HL,BUFFER+1000h`. There are operators with mandatory arguments, others with no arguments defined, and others with optional arguments.

Control characters other than tabs are stripped from the source lines before processing, however the form feed characters (encoded as `0xFF` in ASCII and similar encodings)
are counted before these are significant when generating a listing file (they force a listing page change).

MACRO-80 assumes that the source code is encoded in ASCII, Nestor80 however supports source code supplied in any character encoding. ‚ú®

MACRO-80 treats source code characters with the high bit set as line numbers generated by a text editor, this is not the case of Nestor80. üö´


### Symbols

A _symbol_ is a named 8 or 16 bit value. When assembling relocatable code this value can belong to the absolute, code or data segment or to a COMMON block. Valid characters for symbols are letters (any unicode letter is allowed, not just ASCII letters ‚ú®), digits, and these: `$.?@_`. The first character of a symbol can't be a digit.

Nestor80 treats symbols in a case-insensitive way, e.g. `foo`, `FOO` and `Foo` refer all to the same symbol.

There's in principle no limit for the length of a symbol ‚ú®, but when assembling relocatable code the maximum length for external and public symbols is 6 characters.
This limitation is given by [the format of the LINK-80 relocatable files](RelocatableFileFormat.md). Nestor80 will issue a warning if it finds two or more external symbols that are
different but share the first 6 characters (since these will get their names truncated and thus be actually the same symbol), and will throw an error if the same happens with public symbols.

When writing relocatable code, the following suffixes are allowed for symbols:

* A symbol reference can have the `##` suffix to indicate that it's an _external symbol_ (a symbol that is defined in another relocatable file). This is equivalent to using the `EXTRN` instruction:

```
ld hl,FOO##

;Equivalent to:

EXTRN FOO
ld hl,FOO
```

* A label can be defined with the `::` suffix (instead of just `:`) to indicate that it's a _public symbol_ (a symbol that can be accessed from another relocatable file). This is equivalent to using the `PUBLIC` instruction:

```
FOO::
  ;Some code

;Equivalent to:

PUBLIC FOO
FOO:
  ;Some code
```


### Numeric constants

Numeric constants can be specified in any [radix](https://en.wikipedia.org/wiki/Radix) from 2 to 16. The default radix is 10 but this can be changed with the `.RADIX` instruction. When the radix is 11 or higher the letters A to F (case insensitive) are used to represents the digits after the 9.

In order to specify a number in a radix different from the default one the following notations can be used
(prefixes and suffixes are case-insensitive):

Notation |  Radix
---------|-----------------
`nnnnB`     | Binary
`nnnnI` üÜï  | Binary
`nnnnD`  |  Decimal
`nnnnM` üÜï  |  Decimal
`nnnnO`  |   Octal
`nnnnQ`  |   Octal
`nnnnH`  |   Hexadecimal
`X'nnnn'`|  Hexadecimal
`#nnnn` üÜï |   Hexadecimal

Overflow of a number beyond two bytes is ignored and the result is the number formed by the low order 16-bits
(e.g. `123456h` is actually `3456h`).

<blockquote>
‚ö† The <code>B</code> and <code>D</code> suffixes are actually unusable when the default radix is 12 or higher and 14 or higher, respectively. Consider the following example:

    .RADIX 16
    DEFW 1010b,1234d

  You might think that these are the binary number `1010` and the decimal number `1234`, but that's not the case: these are actually the hexadecimal numbers `010B` and `234D`. This behavior is inherited from MACRO-80.

  That's the reason why the new suffixes `I` (b**I**nary) and `M` (deci**M**al) have been introduced in Nestor80.
</blockquote>

‚ö† The `#` prefix for hexadecimal numbers has been introduced in Nestor80 for compatibility with other assemblers that 
use the same notation, but in general it's recommended to use the `H` suffix instead since `#` could cause
confusion with the suffix for external symbols, `##`.

A string can be used as equivalent to the numeric constant resulting from encoding it with the current character encoding, with the following rules:

1. The current character encoding must produce at most two bytes for the string (an error will be thrown otherwise).
2. A string that produces two bytes in the current character encoding is interpreted as a big-endian value in `DEFB` instructions, and as a low-endian value elsewhere.
3. An empty string produces no output in a `DEFB` statement, and the value zero everywhere else.

The second rule exists for consistency with how `DEFB` converts strings into bytes in the general case (strings of any length).

The following example listing illustrates how strings are converted to bytes following these rules:

```
                         .STRENC ASCII
  0000                   defb ''
  0000    41             defb 'A'
  0001    42 41          defw 'AB'
  0003    41 42          defb 'AB'
  0005    41 42 43 44    defb 'ABCD'
  0009    00 00          defw ''
  000B    3E 00          ld a,''
  000D    21 00 00       ld hl,''
```

### Strings

Strings are sequences of arbitrary characters enclosed in single quotes, `'`, or double quotes, `"`. Strings are converted to bytes using the current character encoding üÜï (MACRO-80 didn't have the concept of "character encodings" and simply outputted the string bytes as they were physically stored in the source file).

The _current character encoding_ is the one specified in a `--string-encoding` argument when running Nestor80, and
can also be changed in code with the `.STRENC` instruction. You can run Nestor80 with the `--list-encodings` argument
to see a list of available encodings. The default encoding when none is specified is 7 bit ASCII.

Strings that produce two or less bytes once converted to bytes can be used anywhere a numeric value is expected,
see ["Numeric constants"](#numeric-constants). Strings of any length can be used in the `DEFB` instruction, in this case characters
are converted to bytes sequentially in the order in which they appear in the string. 

Single-quoted strings don't accept escape character with the only exception of `''`, which allows escaping the single quote itself. Example:

```
DEFB 'This ain''t gonna escape much'
```

Double-quoted strings accept escape sequences by default using the `\` character as the sequence initiator üÜï. The following escape sequences are allowed (values are in the ASCII encoding except where otherwise stated):

Sequence | Name | Value
---------|------|--------
\\' | Single quote | 27h
\\" | Double quote | 22h
\\\ | Backslash | 5Ch
\0 | Null  | 00h
\a | Alert | 07h
\b | Backspace | 08h
\f | Form feed | 0Ch
\n | New line | 0Ah
\r | Carriage return | 0Dh
\t | Horizontal tab | 09h
\v | Vertical tab | 0Bh
\u | Unicode escape sequence (4 hex digits) | Example: \u0012 = 12h<br/>Example: \uABCD = CDh, ABh (in UTF-16)

The support for escape sequences in double-quoted strings can be disabled by using the Nestor80 command line argument `--no-string-escapes` or the instruction `.STRESC OFF` in code. When escape sequences are disabled the double quote
character itself can still be escaped by doubling it:

```
.STRESC OFF
db "The ""escaped"" string"
```

‚ö† It's recommended to disable escape sequences when compiling old code that contains strings, since in MACRO-80
the `\` character was considered a regular character with no escaping meaning.
<br/><br/>
‚ö† Note that when string escaping is enabled the only way to escape the double quote character is to use the `\"` sequence or the `\u0022` sequence; the special sequence `""` is available only when escape sequences are disabled.

An empty string (e.g. `DEFB ''`) produces no output.


### Expressions

An _expression_ is a combination of numeric constants, symbols and arithmetic operators that are ultimately evaluated to a numeric value. When assembling relocatable code, expressions that contain external symbol references aren't evaluated; instead, they are outputted to the target relocatable file "as is" to that the evaluation will happen at linking time once the values of all the involved external references have been resolved (see "Writing relocatable code").

Nestor80 defines the following arithmetic operators:

Operator | Meaning | Precedence | Allowed with externals?
---------|---------|------------|------------------------
`NUL`      | Rest of expression<br/> is empty? | 10 | See note
`TYPE`     | Argument type | 9 | See note
`LOW`      | Low byte | 8 | ‚úîÔ∏è
`HIGH`     | High byte | 8 | ‚úîÔ∏è
`*`        | Multiplication | 7 | ‚úîÔ∏è
`/`        | Integer division | 7 | ‚úîÔ∏è
`MOD`      | Remaining of<br/>integer division | 7 | ‚úîÔ∏è
`SHR`      | Shift right | 7 | ‚ùå
`SHL`      | Shift left | 7 | ‚ùå
`-` (unary) | Unary minus | 6 | ‚úîÔ∏è
`+`        | Addition | 5 | ‚úîÔ∏è
`-`        | Substraction  | 5 | ‚úîÔ∏è
`EQ`       | Equals | 4 | ‚ùå
`=` üÜï    | Equals | 4 | ‚ùå
`NE`       | Not equals | 4 | ‚ùå
`NEQ` üÜï  | Not equals | 4 | ‚ùå
`LT`       | Less than | 4 | ‚ùå
`LE`       | Less than or equal  | 4 | ‚ùå
`LTE` üÜï  | Less than or equal  | 4 | ‚ùå
`GT`       | Greater than | 4 | ‚ùå
`GE`       | Greater than or equal | 4 | ‚ùå
`GTE` üÜï  | Greater than or equal | 4 | ‚ùå
`NOT`      | Bitwise NOT<br/>(one's complement) | 3 | ‚úîÔ∏è
`AND`      | Bitwise AND | 2 | ‚ùå
`OR`       | Bitwise OR | 1 | ‚ùå
`XOR`      | Bitwise XOR | 1 | ‚ùå

The `NUL` and `TYPE` operators are special:

* `NUL` works as follows: if the remaining of the source code line after the operator (not including the comment, if present) has any characters other than spaces and tabs, it will evaluate to 0; otherwise it will evaluate to 0FFFFh. This is useful mainly in the context of macro expansions.

* `TYPE` will evaluate to a fixed absolute value depending on the type of the argument passed to it:

Argument type |  Value
--------------|-------
External symbol reference | 0x80
Numeric constant or absolute symbol | 0x20
Symbol defined in the code segment | 0x21
Symbol defined in the data segment | 0x22
Symbol defined in a COMMON block | 0x23

For example `TYPE FOO##` evaluates to 0x80, and `TYPE FOO` evaluates to 0x21 if `FOO` is a label defined in the code segment. Of course, when assembling absolute code `TYPE` will evaluate everything to 0x20.

‚ö†üö´ The `TYPE` operator is intended to be used with plain symbols and will act weirdly with complex expressions. For example, `TYPE (FOO##+1)` will evaluate to A0h in MACRO-80 and throw an error in Nestor80.

The operator precedence determines how the expression is evaluated: subexpressions involving operators of higher precedence are computed first, and operators with the same precedence are applied in the order in which they appear in the expression. For example, the expression `2+3*4` evaluates to 14 because `*` has higher precedence than `+`. Parenthesis can be used to override the default operator precedence, for example `(2+3)*4` evaluates to 20.

The `HIGH` and `LOW` operators evaluate to the high and low byte of a 16 bit value, respectively; for example `HIGH 1234h` is 12h and `LOW 1234h` is 34h. When applied to relocatable values, the entire 16 bit value is written to the generated relocatable file and the evaluation is performed at linking time; for example if `FOO` is a label defined as address 1234h in the code segment, and the linker is instructed to use address 8511h as the base for the code segment, then `HIGH FOO` will properly evaluate to 97h and `LOW FOO` to 45h in the target program.

When writing relocatable code only a subset of the existing operators can be used in expressions involving external references, this is a limitation given by [the relocatable file format](RelocatableFileFormat.md). Trying to use one of the unsupported operators in such an expression will result in an assembly error.


#### Expression interpolation üÜï

The messages to be printed during the assembly process with the `.PRINT`, `.WARN`, `.ERROR` and `.FATAL` instructions support _expression interpolation_, that is, they can include expressions that will be evaluated and the result printed as part of the message.

To interpolate an expression in an instruction it must be enclosed in `{` and `}`, using the following format:

```
{expression[:radix[size]]}
```

where:

* `radix` specifies the radix to use to print the expression value, and can be one of the following:
  * `D` or `d` for decimal.
  * `B` or `b` for binary.
  * `X` or `H` for hexadecimal with uppercase letters.
  * `x` or `h` for hexadecimal with lowercase letters.

The default radix used if none specified is 10, regardless of any radix set with the `.RADIX` instruction.

* `size` is the minimum number of digits that will be printed. The printed value will be padded to the left with zeros if needed.

For example, the following line

```
.print 20+11 equals {20+11}, or {20+11:H}h, or {20+11:x4}h, or {20+11:b8}b.
```

will print

```
20+11 equals 31, or 1Fh, or 001fh, or 00011111b.
```

‚ö† All the symbols included in interpolated expressions must be known when the instruction is processed (this implies that the expressions can't contain external symbol references), otherwise an error will be thrown and the messages will be printed with the "offending" expressions unevaluated. Usually you'll want to use `.PRINT2` instead of `.PRINT` or `.PRINT1` to ensure that.


#### Bare expressions

MACRO-80 allows _bare expressions_ lines, these are lines that have no operand and contain just a list of comma-separated expressions; these lines are treated as `DEFB` instructions. For example the line `1,2,3,4` is equivalent to `DEFB 1,2,3,4`.

In Nestor80 bare expressions aren't supported by default üö´, but they will be supported if the `--allow-bare-expressions` command line argument is used. You might need this to assemble old source code, but in general bare expressions shouldn't be used since they can cause confussion (for example if you intend to introduce a named macro expansion and mistype the macro name you'll get a confusing "symbol not found" error).


## Advanced features

### Modules ‚ú®

A _module_ is a set of consecutive source code lines grouped under a unique name. All symbols defined inside a module (and by default, also all the non-external referenced symbols) will be considered _relative_ to the module name; this means that the effective symbol name will be `module_name.symbol`. Example:

```
MAIN_INIT:
  call GRAPHICS.init
  call SOUND.init
  ret

module GRAPHICS

init:
  ;Some unique init
initloop:
  ;Some repeated init
  djnz initloop
  ret

endmod

module SOUND

init:
  ;Some unique init
initloop:
  ;Some repeated init
  djnz initloop
  ret

endmod
```

The above code is equivalent to the following one that doesn't use modules:

```
MAIN_INIT:
  call GRAPHICS.init
  call SOUND.init
  ret

GRAPHICS.init:
  ;Some unique init
GRAPHICS.initloop:
  ;Some repeated init
  djnz GRAPHICS.initloop
  ret

SOUND.init:
  ;Some unique init
SOUND.initloop:
  ;Some repeated init
  djnz SOUND.initloop
  ret
```

In order to refer to a symbol defined outside the module there are two options:

1. Prepend the symbol name with a colon, `:`
2. Use the `ROOT` instruction to list the symbols that are to be considered as defined outside the module.

Example:

```
CHPUT equ 00A2h

MAIN_INIT:
  call GRAPHICS.init
  call SOUND.init
  ret

module GRAPHICS

init:
  ld a,'!'
  call :CHPUT
  ret

endmod

module SOUND

root CHPUT

init:
  ld a,'?'
  call CHPUT
  ret

endmod
```

Modules can be nested:

```
MAIN_INIT:
  call GRAPHICS.LOWRES.init
  ret

module GRAPHICS
module LOWRES

init:
  ;Do init
  ret

endmod
endmod
```

When a symbols starts with a dot, no extra dot will be added when concatenating the symbol name and the module name, so `.symbol` becomes `module.symbol`, not `module..symbol`:

```
MAIN_INIT:
  call GRAPHICS.init
  call GRAPHICS..reinit
  ret

module GRAPHICS

.init:
  ;Do init
  ret

..reinit:
  ;Do reinit
  ret

endmod
```


### Relative labels ‚ú®

A _relative label_ is a label that starts with a dot, `.`, and is found after a non-relative label; the former is considered to be relative to the later, that is, the effective label name for `.relative` is `non_relative.relative`:

```
.relab

print:
  ;Init
.loop:
  ;Stuff
  djnz .loop
  ret	

update:
  ;Init
.loop:
  ;Stuff
  djnz .loop
  ret	
```

The above code is equivalent to the following one that doesn't use relative labels:

```
print:
  ;Init
print.loop:
  ;Stuff
  djnz print.loop
  ret	

update:
  ;Init
update.loop:
  ;Stuff
  djnz update.loop
  ret	
```

‚ö† Relative labels are disabled by default. To enable the feature the `.RELAB` instruction must be used; conversely, the `.XRELAB` instruction disables the feature.

Any symbol whose name starts with a dot will be considered a relative label if the feature is enabled and at least one non-relative label has been declared. In order to reference a symbol whose name starts with a dot but is not a relative label there are two options:

1. Prepend the symbol name with a colon, `:`
2. Temporarily disable the relative labels with `.XRELAB`

Example:

```
.STROUT equ 09h
BDOS equ 0005h

print:
  ld c,:.STROUT
  call BDOS
  ret	

reprint:
  .xrelab
  ld c,.STROUT
  .relab
  call BDOS
  ret
```

The last non-relative symbol is forgotten (and thus symbols starting with a dot go back to being considered regular symbols) when:

1. A module is entered (`MODULE` instruction) or exited (`ENDMOD` instruction).
2. The feature is enabled with `.RELAB` or disabled with `.XRELAB` (even if it was already enabled or disabled).

‚ö† The relative symbols feature affects not only the symbol _usages_ but also the symbol _definitions_, which can be confusing. Consider this example:

```
.relab

foo:
  ;Do stuff
  ret

.STROUT equ 09h  ;"Symbol .STROUT not found" error because this is actually foo.STROUT !!
```

If you need to declare non-relative constants whose name starts with a dot make sure to either:

* Declare them at the beginning of the code, before any non-relative label is declared; or
* Declare them with the feature disabled (with `.XRELAB`); or
* Use an extra `.RELAB` before the constant declaration to force Nestor80 to forget the last non-relative label.

As a rule of thumb it's a good idea to enable the feature only when really needed.

# Nestor80 assembler language reference

This documents details the source file format supported by Nestor80 and lists all the available assembler instructions (called "pseudo-operators" in the MACRO-80 manual), both the ones inherited from MACRO-80 and the ones newly introduced by Nestor80.


## Document conventions

The following icons are used in this document:

🆕 A "new" icon is used when introducing a feature or instruction that is new in Nestor80 (it wasn't available in MACRO-80).

✨ A "sparks" icon is used when referring to a feature or instruction that was already available in MACRO-80 but has been enhanced or improved in a backwards-compatible way in Nestor80.

🚫 A "forbidden" icon is used to refer to a MACRO-80 feature or instruction that is not available or has changed in a backwards-incompatible way in Nestor80. Old source code intended for MACRO-80 and relying in such features or instructions will likely require changes before being suitable for assembly with Nestor80.

⚠ A "warning" icon is used when discussing a tricky, subtle or confusing subject; or in general to bring attention to an important concept.

Text in _italics_ will be used the first time a new term or concept is introduced. Alternatively, when a concept or term that is introduced in a later section is used, it will link to the defining section.


## Basic concepts

Before detailing the assembler language reference a couple of concepts related to how the assembler works will be introduced.


### Passes

Nestor80 is a _two pass assembler_. This means that the source code is processed twice: the first time the assembler determines how many bytes each source code line will use in the _target program_ (the contents of the binary file resulting from processing the source code) and updates the current _location counter_ (the pointer in Z80 memory where the code generated by each line will be loaded) accordingly, using this information to assign the appropriate values to labels. The second time, already with all the label values at hand, is when the code is actually assembled.

Let's see a simple example:

```
org 100h
call PROGRAM
ret
PROGRAM:
;Some code here
RET
```

In pass 1 the assembler does the following:

1. It sees a `CALL PROGRAM` instruction and although the value of `PROGRAM` is still unknown, one thing that is for sure is that the line will use three bytes of memory in the target program. Thus, the current location counter is updated to 103h.
2. It sees a `RET` instruction and knows that it will use one byte, thus the location counter is updated to 104h.
3. It sees the definition of the `PROGRAM` label and assigns it the value of the current location counter, 104h.
4. It processes the rest of the code accordingly.

In pass 2 the assembler already knows the value of `PROGRAM` and thus processes the second line as if it was `CALL 0104h`, writing `CDh 04h 01h` to the target program.

A similar processing happens for other types of symbols that don't depend on the location counter but may be unknown when found in pass 1, e.g. constants:

```
call CHPUT
ret
CHPUT equ 00A2h
```

Usually the fact that the assembly process takes two passes is transparent for the developer, but the `IF1` and `IF2` instructions exist for advanced scenarios in which it's convenient to process different blocks of source code depending on the current pass. This is typically used to prevent the output of duplicated messages during the assembly process with `.PRINT`, `.WARN` or `.ERR`.

Here's an advanced example from the source code of [Nextor](https://github.com/Nextor). The following macro will store the value of a given symbol, but if the symbol is undefined by the time the macro is expanded in pass 2, it will be specified as an external symbol reference (with the `##` suffix); the `DEFW 0` in pass 1 is needed to keep the location counter consistent in both passes:

```
DEFA MACRO ADDR
 IF1
  DEFW	0
 ELSE
  IFDEF	ADDR
   DEFW	ADDR
  ELSE
   DEFW	ADDR##
  ENDIF
 ENDIF
ENDM
```

⚠ Unlike MACRO-80, Nestor80 will skip pass 2 if errors are found in pass 1  (but not if only warnings are found). Thus during the development process it's possible to find that some assembly errors seemingly "appear from nowhere" after some other errors were fixed (the former being errors found in pass 2 and the later being errors found in pass 1). A fatal error will terminate the assembly process immediately.

The location counter can be temporarily modified to account for code that will be executed at a different address, see `.PHASE`.


### Absolute and relocatable code

Nestor80 can produce both absolute 🆕 and relocatable files.

* An _absolute file_ contains code "ready to use", intended to be loaded and executed at the fixed memory locations indicated by the `ORG` instructions found in code (or begninning at address 0, if no such instructions are provided). Most assemblers produce only absolute files.

* _Relocatable files_ have [a dedicated format](RelocatableFileFormat.md) and contain relocatable code, that is, "pre-assembled" code in which labels are flagged as being relative to the memory address where the target program will be loaded and symbols may be flagged as _external_, that is, defined in other relocatable file.

Relocatable files can't be executed, instead a linker (typically LINK-80) must be used to convert it into an absolute file by providing the actual loading memory addresses for the target program. The linker is typically used to "glue together" two or more of these files (and linking public symbols with the corresponding external symbols).

It's possible to instruct Nestor80 to produce an absolute file or a relocatable file by using the `--build-type` command line argument, but by default Nestor80 will decide the appropriate type automatically. The decision is taken as follows:

> If an `ORG` instruction is found in the source code before a CPU instruction, a label defined as public with  `::`, or any of the following instructions: `CSEG`, `DSEG`, `COMMON`, `DEFB`, `DEFW`, `DEFS`, `DC`, `DEFZ`, `PUBLIC`, `EXTRN`, `.REQUEST`, then the build type will be absolute; otherwise the build type will be relocatable.

Put it another way, if you want your code to be automatically detected as intended to be assembled as absolute, use an `ORG` instruction as the first "effective" source code line (so the first line except blanks, comments, macro definitions and constant definitions).

⚠ If the build type is forced to absolute with `--build-type` but the code contains no `ORG` instructions, an implicit `ORG 0` at the beginning of the code is assumed.

Some assembler instructions make sense only in the context of relocatable code, for example `CSEG`, `DSEG`, `PUBLIC` OR `EXTRN`; these instructions will do nothing, and the assembler will throw warnings, if they are found while assembling absolute code. 

See "Writing relocatable code" for more details about how relocatable code programming works.


## Source code format

Nestor80 converts source code files to absolute or relocatable files. A source code file is a text file in which each line is either blank, a _comment_, or a _statement_; lines
are processed one by one. The maximum supported line length is 1034 characters ✨ and all the usual line ending conventions are supported (CR+LF characters, LF only, and CR only). ✨ 
Spaces and tabs are treated equivalently, and those found at the beginning and at the end of the line are removed before the line is processed.

A comment-only line starts with a semicolon character, `;`,  and has no effect in the assembly process. A statement has the following format:

```
[label:[:]] [operator] [arguments] [;comment]
```

Any number of spaces or tabs can be used to separate the statement components.

A _label_ is a type of symbol that has the value of the location counter at the time it's defined (the value that the location counter has when the line is processed).
A label definition must end with either `:` or `::`; the later is used when assembling relocatable code to indicate that the label is public.

An _operator_ is a word that can be either the mnemonic of a CPU instruction (e.g. `LD`) or an assembler instruction. An _assembler instruction_ (called "pseudo-operator"
in the MACRO-80 manual) is an instruction for the assembler itself, for example `ORG` instructs the assembler to change the value of the current location counter.

> ⚠ In this manual the word "instruction" alone will be used to refer to assembler instructions, as opposed to CPU instructions.

The comment, if present, runs until the end of the line and has no effect in the assembly process. Multiline comments are supported by using the `.COMMENT` instruction.

Nestor80 supports Z80 and R800 🆕 CPU instructions, being Z80 the default CPU; a `.CPU R800` instruction can be used to enable support for R800 instructions.
The 8080 CPU is not supported by Nestor80. 🚫

The arguments depend on the operator. For CPU instructions they will typically be one or two comma-separated values, each being either a CPU register name or an expression,
for example `LD HL,BUFFER+1000h`. There are operators with mandatory arguments, others with no arguments defined, and others with optional arguments.

Control characters other than tabs are stripped from the source lines before processing, however the form feed characters (encoded as `0xFF` in ASCII and similar encodings)
are counted before these are significant when generating a listing file (they force a listing page change).

MACRO-80 assumes that the source code is encoded in ASCII, Nestor80 however supports source code supplied in any character encoding. ✨

MACRO-80 treats source code characters with the high bit set as line numbers generated by a text editor, this is not the case of Nestor80. 🚫


### Symbols

A _symbol_ is a named 8 or 16 bit value. When assembling relocatable code this value can belong to the absolute, code or data segment or to a COMMON block. Valid characters for symbols are letters (any unicode letter is allowed, not just ASCII letters ✨), digits, and these: `$.?@_`. The first character of a symbol can't be a digit.

Nestor80 treats symbols in a case-insensitive way, e.g. `foo`, `FOO` and `Foo` refer all to the same symbol.

There's in principle no limit for the length of a symbol ✨, but when assembling relocatable code the maximum length for external and public symbols is 6 characters.
This limitation is given by [the format of the LINK-80 relocatable files](RelocatableFileFormat.md). Nestor80 will issue a warning if it finds two or more external symbols that are
different but share the first 6 characters (since these will get their names truncated and thus be actually the same symbol), and will throw an error if the same happens with public symbols.

When writing relocatable code, the following suffixes are allowed for symbols:

* A symbol reference can have the `##` suffix to indicate that it's an _external symbol_ (a symbol that is defined in another relocatable file). This is equivalent to using the `EXTRN` instruction:

```
ld hl,FOO##

;Equivalent to:

EXTRN FOO
ld hl,FOO
```

* A label can be defined with the `::` suffix (instead of just `:`) to indicate that it's a _public symbol_ (a symbol that can be accessed from another relocatable file). This is equivalent to using the `PUBLIC` instruction:

```
FOO::
  ;Some code

;Equivalent to:

PUBLIC FOO
FOO:
  ;Some code
```

### Named constants

A _named constant_ (or just "constant") is a symbol that represents a numeric value and can be used in expressions. There are two types of constants: fixed and redefinible. The value of a _fixed_ constant can't be altered, while the value of a _redefinible_ constant can, by using a new constant definition instruction with the same constant name.

A fixed constant is defined using the following syntax: `<name>[:] EQU <value expression>`. The colon after the constant name is optional ✨ (in Macro80 the colon after the constant name isn't allowed). Example:

```
FOO equ 34
FOO: equ 30+4  ;Allowed since the value is the same

ld a,FOO+6     ;Equivalent to "ld a,40"

FOO equ 89     ;"Symbol already exists" error
```

A redefinible constant is (re)defined using the following syntax: `<name>[:] DEFL <value expression>`. As in the case of the fixed constants, the colon after the constant name is optional ✨. Example:

```
FOO defl 34
ld a,FOO      ;Equivalent to "ld a,34"

FOO: defl 89
ld a,FOO      ;Equivalent to "ld a,89"

FOO defl FOO+1   ;The constant itself can be part of the redefinition expression
ld a,FOO      ;Equivalent to "ld a,90"
```

For compatibility with Macro80 the `ASET` instruction is allowed as an alias for `DEFL`.


Note that `EQU` and `DEFL` can't be mixed for the same constant name:

```
FOO equ 1
FOO defl 2    ;"Symbol already exists" error
```

```
FOO defl 1
FOO equ 2     ;"Symbol already exists" error
```

⚠ You may think that the term "constant" isn't really appropriate for redefinible values. The term "variable", however, has been avoided on purpose to avoid confussion with how the word is normally used in the context of software development, as "value that can change at runtime"; a redefinible constant can have its value changed _at assemble time_, **not** at runtime.

⚠ (🚫?) The Macro80 manual mentions also the instruction `SET` as an additional alias for `DEFL`, but in practice it doesn't work as such: `SET` is only recognized as the Z80 instruction of the same name in Macro80. Nestor80 behaves as Macro80 behaves and not as the Macro80 documentation says, so you can't use `SET` to define constants.


### Numeric constants

Numeric constants can be specified in any [radix](https://en.wikipedia.org/wiki/Radix) from 2 to 16. The default radix is 10 but this can be changed with the `.RADIX` instruction. When the radix is 11 or higher the letters A to F (case insensitive) are used to represents the digits after the 9.

In order to specify a number in a radix different from the default one the following notations can be used
(prefixes and suffixes are case-insensitive):

Notation |  Radix
---------|-----------------
`nnnnB`     | Binary
`nnnnI` 🆕  | Binary
`nnnnD`  |  Decimal
`nnnnM` 🆕  |  Decimal
`nnnnO`  |   Octal
`nnnnQ`  |   Octal
`nnnnH`  |   Hexadecimal
`X'nnnn'`|  Hexadecimal
`#nnnn` 🆕 |   Hexadecimal

Overflow of a number beyond two bytes is ignored and the result is the number formed by the low order 16-bits
(e.g. `123456h` is actually `3456h`).

<blockquote>
⚠ The <code>B</code> and <code>D</code> suffixes are actually unusable when the default radix is 12 or higher and 14 or higher, respectively. Consider the following example:

    .RADIX 16
    DEFW 1010b,1234d

  You might think that these are the binary number `1010` and the decimal number `1234`, but that's not the case: these are actually the hexadecimal numbers `010B` and `234D`. This behavior is inherited from MACRO-80.

  That's the reason why the new suffixes `I` (b**I**nary) and `M` (deci**M**al) have been introduced in Nestor80.
</blockquote>

⚠ The `#` prefix for hexadecimal numbers has been introduced in Nestor80 for compatibility with other assemblers that 
use the same notation, but in general it's recommended to use the `H` suffix instead since `#` could cause
confusion with the suffix for external symbols, `##`.

A string can be used as equivalent to the numeric constant resulting from encoding it with the current character encoding, with the following rules:

1. The current character encoding must produce at most two bytes for the string (an error will be thrown otherwise).
2. A string that produces two bytes in the current character encoding is interpreted as a big-endian value in `DEFB` instructions, and as a low-endian value elsewhere.
3. An empty string produces no output in a `DEFB` statement, and the value zero everywhere else.

The second rule exists for consistency with how `DEFB` converts strings into bytes in the general case (strings of any length).

The following example listing illustrates how strings are converted to bytes following these rules:

```
                         .STRENC ASCII
  0000                   defb ''
  0000    41             defb 'A'
  0001    42 41          defw 'AB'
  0003    41 42          defb 'AB'
  0005    41 42 43 44    defb 'ABCD'
  0009    00 00          defw ''
  000B    3E 00          ld a,''
  000D    21 00 00       ld hl,''
```

### Strings

Strings are sequences of arbitrary characters enclosed in single quotes, `'`, or double quotes, `"`. Strings are converted to bytes using the current character encoding 🆕 (MACRO-80 didn't have the concept of "character encodings" and simply outputted the string bytes as they were physically stored in the source file).

The _current character encoding_ is the one specified in a `--string-encoding` argument when running Nestor80, and
can also be changed in code with the `.STRENC` instruction. You can run Nestor80 with the `--list-encodings` argument
to see a list of available encodings. The default encoding when none is specified is 7 bit ASCII.

Strings that produce two or less bytes once converted to bytes can be used anywhere a numeric value is expected,
see ["Numeric constants"](#numeric-constants). Strings of any length can be used in the `DEFB` instruction, in this case characters
are converted to bytes sequentially in the order in which they appear in the string. 

Single-quoted strings don't accept escape character with the only exception of `''`, which allows escaping the single quote itself. Example:

```
DEFB 'This ain''t gonna escape much'
```

Double-quoted strings accept escape sequences by default using the `\` character as the sequence initiator 🆕. The following escape sequences are allowed (values are in the ASCII encoding except where otherwise stated):

Sequence | Name | Value
---------|------|--------
\\' | Single quote | 27h
\\" | Double quote | 22h
\\\ | Backslash | 5Ch
\0 | Null  | 00h
\a | Alert | 07h
\b | Backspace | 08h
\f | Form feed | 0Ch
\n | New line | 0Ah
\r | Carriage return | 0Dh
\t | Horizontal tab | 09h
\v | Vertical tab | 0Bh
\u | Unicode escape sequence (4 hex digits) | Example: \u0012 = 12h<br/>Example: \uABCD = CDh, ABh (in UTF-16)

The support for escape sequences in double-quoted strings can be disabled by using the Nestor80 command line argument `--no-string-escapes` or the instruction `.STRESC OFF` in code. When escape sequences are disabled the double quote
character itself can still be escaped by doubling it:

```
.STRESC OFF
db "The ""escaped"" string"
```

⚠ It's recommended to disable escape sequences when compiling old code that contains strings, since in MACRO-80
the `\` character was considered a regular character with no escaping meaning.
<br/><br/>
⚠ Note that when string escaping is enabled the only way to escape the double quote character is to use the `\"` sequence or the `\u0022` sequence; the special sequence `""` is available only when escape sequences are disabled.

An empty string (e.g. `DEFB ''`) produces no output.


### Expressions

An _expression_ is a combination of numeric constants, symbols and arithmetic operators that are ultimately evaluated to a numeric value. When assembling relocatable code, expressions that contain external symbol references aren't evaluated; instead, they are outputted to the target relocatable file "as is" to that the evaluation will happen at linking time once the values of all the involved external references have been resolved (see "Writing relocatable code").

Nestor80 defines the following arithmetic operators:

Operator | Meaning | Precedence | Allowed with externals?
---------|---------|------------|------------------------
`NUL`      | Rest of expression<br/> is empty? | 10 | See note
`TYPE`     | Argument type | 9 | See note
`LOW`      | Low byte | 8 | ✔️
`HIGH`     | High byte | 8 | ✔️
`*`        | Multiplication | 7 | ✔️
`/`        | Integer division | 7 | ✔️
`MOD`      | Remaining of<br/>integer division | 7 | ✔️
`SHR`      | Shift right | 7 | ❌
`SHL`      | Shift left | 7 | ❌
`-` (unary) | Unary minus | 6 | ✔️
`+`        | Addition | 5 | ✔️
`-`        | Substraction  | 5 | ✔️
`EQ`       | Equals | 4 | ❌
`=` 🆕    | Equals | 4 | ❌
`NE`       | Not equals | 4 | ❌
`NEQ` 🆕  | Not equals | 4 | ❌
`LT`       | Less than | 4 | ❌
`LE`       | Less than or equal  | 4 | ❌
`LTE` 🆕  | Less than or equal  | 4 | ❌
`GT`       | Greater than | 4 | ❌
`GE`       | Greater than or equal | 4 | ❌
`GTE` 🆕  | Greater than or equal | 4 | ❌
`NOT`      | Bitwise NOT<br/>(one's complement) | 3 | ✔️
`AND`      | Bitwise AND | 2 | ❌
`OR`       | Bitwise OR | 1 | ❌
`XOR`      | Bitwise XOR | 1 | ❌

The `NUL` and `TYPE` operators are special:

* `NUL` works as follows: if the remaining of the source code line after the operator (not including the comment, if present) has any characters other than spaces and tabs, it will evaluate to 0; otherwise it will evaluate to 0FFFFh. This is useful mainly in the context of macro expansions.

* `TYPE` will evaluate to a fixed absolute value depending on the type of the argument passed to it:

Argument type |  Value
--------------|-------
External symbol reference | 0x80
Numeric constant or absolute symbol | 0x20
Symbol defined in the code segment | 0x21
Symbol defined in the data segment | 0x22
Symbol defined in a COMMON block | 0x23

For example `TYPE FOO##` evaluates to 0x80, and `TYPE FOO` evaluates to 0x21 if `FOO` is a label defined in the code segment. Of course, when assembling absolute code `TYPE` will evaluate everything to 0x20.

⚠🚫 The `TYPE` operator is intended to be used with plain symbols and will act weirdly with complex expressions. For example, `TYPE (FOO##+1)` will evaluate to A0h in MACRO-80 and throw an error in Nestor80.

The operator precedence determines how the expression is evaluated: subexpressions involving operators of higher precedence are computed first, and operators with the same precedence are applied in the order in which they appear in the expression. For example, the expression `2+3*4` evaluates to 14 because `*` has higher precedence than `+`. Parenthesis can be used to override the default operator precedence, for example `(2+3)*4` evaluates to 20.

The `HIGH` and `LOW` operators evaluate to the high and low byte of a 16 bit value, respectively; for example `HIGH 1234h` is 12h and `LOW 1234h` is 34h. When applied to relocatable values, the entire 16 bit value is written to the generated relocatable file and the evaluation is performed at linking time; for example if `FOO` is a label defined as address 1234h in the code segment, and the linker is instructed to use address 8511h as the base for the code segment, then `HIGH FOO` will properly evaluate to 97h and `LOW FOO` to 45h in the target program.

When writing relocatable code only a subset of the existing operators can be used in expressions involving external references, this is a limitation given by [the relocatable file format](RelocatableFileFormat.md). Trying to use one of the unsupported operators in such an expression will result in an assembly error.


#### Expression interpolation 🆕

The messages to be printed during the assembly process with the `.PRINT`, `.WARN`, `.ERROR` and `.FATAL` instructions support _expression interpolation_, that is, they can include expressions that will be evaluated and the result printed as part of the message.

To interpolate an expression in an instruction it must be enclosed in `{` and `}`, using the following format:

```
{expression[:radix[size]]}
```

where:

* `radix` specifies the radix to use to print the expression value, and can be one of the following:
  * `D` or `d` for decimal.
  * `B` or `b` for binary.
  * `X` or `H` for hexadecimal with uppercase letters.
  * `x` or `h` for hexadecimal with lowercase letters.

The default radix used if none specified is 10, regardless of any radix set with the `.RADIX` instruction.

* `size` is the minimum number of digits that will be printed. The printed value will be padded to the left with zeros if needed.

For example, the following line

```
.print 20+11 equals {20+11}, or {20+11:H}h, or {20+11:x4}h, or {20+11:b8}b.
```

will print

```
20+11 equals 31, or 1Fh, or 001fh, or 00011111b.
```

⚠ All the symbols included in interpolated expressions must be known when the instruction is processed (this implies that the expressions can't contain external symbol references), otherwise an error will be thrown and the messages will be printed with the "offending" expressions unevaluated. Usually you'll want to use `.PRINT2` instead of `.PRINT` or `.PRINT1` to ensure that.


#### Bare expressions

MACRO-80 allows _bare expressions_ lines, these are lines that have no operand and contain just a list of comma-separated expressions; these lines are treated as `DEFB` instructions. For example the line `1,2,3,4` is equivalent to `DEFB 1,2,3,4`.

In Nestor80 bare expressions aren't supported by default 🚫, but they will be supported if the `--allow-bare-expressions` command line argument is used. You might need this to assemble old source code, but in general bare expressions shouldn't be used since they can cause confussion (for example if you intend to introduce a named macro expansion and mistype the macro name you'll get a confusing "symbol not found" error).


## Advanced features

### Modules ✨

A _module_ is a set of consecutive source code lines grouped under a unique name. All symbols defined inside a module (and by default, also all the non-external referenced symbols) will be considered _relative_ to the module name; this means that the effective symbol name will be `module_name.symbol`. Example:

```
MAIN_INIT:
  call GRAPHICS.init
  call SOUND.init
  ret

module GRAPHICS

init:
  ;Some unique init
initloop:
  ;Some repeated init
  djnz initloop
  ret

endmod

module SOUND

init:
  ;Some unique init
initloop:
  ;Some repeated init
  djnz initloop
  ret

endmod
```

The above code is equivalent to the following one that doesn't use modules:

```
MAIN_INIT:
  call GRAPHICS.init
  call SOUND.init
  ret

GRAPHICS.init:
  ;Some unique init
GRAPHICS.initloop:
  ;Some repeated init
  djnz GRAPHICS.initloop
  ret

SOUND.init:
  ;Some unique init
SOUND.initloop:
  ;Some repeated init
  djnz SOUND.initloop
  ret
```

In order to refer to a symbol defined outside the module there are two options:

1. Prepend the symbol name with a colon, `:`
2. Use the `ROOT` instruction to list the symbols that are to be considered as defined outside the module.

Example:

```
CHPUT equ 00A2h

MAIN_INIT:
  call GRAPHICS.init
  call SOUND.init
  ret

module GRAPHICS

init:
  ld a,'!'
  call :CHPUT
  ret

endmod

module SOUND

root CHPUT

init:
  ld a,'?'
  call CHPUT
  ret

endmod
```

Modules can be nested:

```
MAIN_INIT:
  call GRAPHICS.LOWRES.init
  ret

module GRAPHICS
module LOWRES

init:
  ;Do init
  ret

endmod
endmod
```

When a symbols starts with a dot, no extra dot will be added when concatenating the symbol name and the module name, so `.symbol` becomes `module.symbol`, not `module..symbol`:

```
MAIN_INIT:
  call GRAPHICS.init
  call GRAPHICS..reinit
  ret

module GRAPHICS

.init:
  ;Do init
  ret

..reinit:
  ;Do reinit
  ret

endmod
```


### Relative labels ✨

A _relative label_ is a label that starts with a dot, `.`, and is found after a non-relative label; the former is considered to be relative to the later, that is, the effective label name for `.relative` is `non_relative.relative`:

```
.relab

print:
  ;Init
.loop:
  ;Stuff
  djnz .loop
  ret

update:
  ;Init
.loop:
  ;Stuff
  djnz .loop
  ret
```

The above code is equivalent to the following one that doesn't use relative labels:

```
print:
  ;Init
print.loop:
  ;Stuff
  djnz print.loop
  ret

update:
  ;Init
update.loop:
  ;Stuff
  djnz update.loop
  ret
```

⚠ Relative labels are disabled by default. To enable the feature the `.RELAB` instruction must be used; conversely, the `.XRELAB` instruction disables the feature.

Within expressions any symbol whose name starts with a dot will be considered a relative label if the feature is enabled and at least one non-relative label has been declared previously, this can lead to errors when referencing constants:

```
.relab

.STROUT equ 09h

FOO:
  ;Do stuff
  ret

ld a,.STROUT  ;Error: symbol "FOO.STROUT" not found
```

In order to reference a symbol whose name starts with a dot but is not a relative label there are two options:

1. Prepend the symbol name with a colon, `:`
2. Temporarily disable the relative labels with `.XRELAB`

Example:

```
.relab

.STROUT equ 09h
BDOS equ 0005h

print:
  ld c,:.STROUT
  call BDOS
  ret	

reprint:
  .xrelab
  ld c,.STROUT
  .relab
  call BDOS
  ret
```

The last non-relative symbol is forgotten (and thus symbols starting with a dot go back to being considered regular symbols) when:

1. A module is entered (`MODULE` instruction) or exited (`ENDMOD` instruction).
2. The feature is enabled with `.RELAB` or disabled with `.XRELAB` (even if it was already enabled or disabled).

Example:


```
.relab

.STROUT equ 09h

FOO:
  ;Do stuff
  ret

.relab

ld a,.STROUT  ;No error, really referencing ".STROUT" due to the second .relab
```


## Assembler instructions reference

This section lists all the assembler instructions supported by Nestor80. Any instruction alias is listed together with the "canonical" instruction name.

® Additionally to the document-wide icons, an "R" symbol next to an instruction name means that the instruction is relevant only when writing relocatable code. If you only write code intended to be assembled as absolute you can skip the documentation for these instructions.


### .COMMENT

_Syntax:_ `.COMMENT <delimiter><text><delimiter>`

Defines a block of comment text with support for multiple lines. The first character found after the instruction will be considered the delimiter, and all text found in the source code until the delimiter is found again will be considered a comment and not processed. Example:

```
.COMMENT * Here we go!

This is a comment, anything until another asterisk is found is ignored.

*

ld a,34 ;Regular code again
```

The entire line where the closing delimiter is found will be considered as part of the comment and thus ignored:

```
.COMMENT *

Blah blah

* This is still ignored!

ld a,34 ;Regular code again
```


### .CPU 🆕

_Syntax:_ `.CPU <cpu name>`

Changes the target CPU for the assembled code. 

Currently the supported CPUs are `Z80` (default) and `R800`. The only difference is that setting the R800 as the target CPU enables the `MULUB` and `MULUW` instructions:

```
MULUB A,A
MULUB A,B
MULUB A,C
MULUB A,D
MULUB A,E
MULUB A,H
MULUB A,L
MULUW HL,BC
MULUW HL,DE
MULUW HL,HL
MULUW HL,SP
```

[The Z80 undocumented instructions](http://www.z80.info/z80undoc.htm) are always supported.


### .CREF 🚫

_Syntax:_ `.CREF` 

In Macro80 this instruction enabled the inclusion of cross-reference information when generating a listing file. Nestor80 doesn't implement cross-reference information generation and thus this instruction does nothing.


### .DEPHASE

_Syntax:_ `.DEPHASE`

Marks the end of a phased code block. See `.PHASE`.


### .ERROR 🆕

_Syntax:_ `.ERROR <text>`

Emits an assembly error with the specified text. The text supports expression interpolation.

When one or more errors are emitted in pass 1, pass 2 will be skipped. See "Passes".


### .FATAL 🆕

_Syntax:_ `.FATAL <text>`

Throws an fatal error with the specified text. The text supports expression interpolation.

A fatal error will terminate the assembly process immediately.


### .LALL

_Syntax:_ `.LALL`

Instructs Nestor80 to include the complete macro text for expanded macros in listings for all macros following the instruction. The default initial condition (also set by `.XALL`) is to include only the source lines that produce any output in the target file (assembler instructions and `DEFB`, `DEFW` etc). See `.XALL`, `.SALL`, "Macros", "Listings".


### .LFCOND

_Syntax:_ `.LFCOND`

Instructs Nestor80 to include conditional blocks that evaluate as false in listings for all the matching blocks following the instruction. This is the default initial condition unless a `--no-listing-false-conditionals` argument is supplied to Nestor80. See also `.LFCOND`, `.TFCOND`, "Conditional blocks", "Listings".


### .LIST

_Syntax:_ `.LIST`

Instructs Nestor80 to include all the source code text following the instruction. This is the default initial condition when Nestor80 is instructed to generate a listing file with the `--listing` argument. See also `.XLIST`, "Listings".


### .PHASE

_Syntax:_ `.PHASE <address>`

Starts a phased code block. A _phased code block_ is a set of instructions that are intended to be run at a different memory address (indicated by the `<address>` argument) than the one dictated by the current location pointer. `.DEPHASE` is used to mark the end of a phased code block.

For example, assume that you have the following code in ROM starting at address 4000h and you have RAM starting at address 8000h. Your ROM is banked, with the bank number selected via Z80 port 10h. This is the code that you could use to calculate the 1 byte checksum of a given bank, together with the addresses and output generated for reference:

```
8000                  RAM_BUFFER equ 8000h
                    
                      org 4000h
                    
4000    21 13 40      ld hl,CALCULATE_CHECKSUM
4003    11 00 80      ld de,8000h
4006    01 1A 00      ld bc,CALCULATE_CHECKSUM_END - CALCULATE_CHECKSUM
4009    ED B0         ldir
                    
400B    3E 01         ld a,1
400D    CD 00 80      call RAM_BUFFER
4010    C3 2D 40      jp MORE_CODE
                    
                    ;Calculate the 1-byte checksum of a ROM bank.
                    ;Input:  A = ROM bank number
                    ;Output: A = Checksum
4013                CALCULATE_CHECKSUM:
                      .phase RAM_BUFFER
                    
8000    D3 10         out (10h),a
8002    16 00         ld d,0
8004    21 00 40      ld hl,4000h
8007    01 00 40      ld bc,4000h
                    
800A                LOOP:
800A    7E            ld a,(hl)
800B    82            add a,d
800C    57            ld d,a
800D    23            inc hl
800E    0B            dec bc
800F    78            ld a,b
8010    B1            or c
8011    C2 0A 80      jp nz,LOOP
                    
8014    3E 00         ld a,0
8016    D3 10         out (10h),a  ;Assume the ROM bank number of the caller was 0
                    
8018    7A            ld a,d
8019    C9            ret
                    
                      .dephase
402D                CALCULATE_CHECKSUM_END:
                    
                      ;Location counter from before .PHASE is restored here,
                      ;appropriately updated by the size of the phased block
402D                MORE_CODE:
402D    3E 22         ld a,34
```

Although the starting address of a phased block will normally be an absolute address, using relocatable addresses is also allowed:

```
0000'                 dseg
                      org 1000h
1000"               FOO:
                  
1000"                 cseg
                  
0000'   3E 22         ld a,34
                  
                      .phase FOO
1000"   00 01 02      db 0,1,2
                      .dephase
                  
0005'   3E 59         ld a,89
```

🚫 There are two restrictions for phased blocks that weren't present in Macro80:

1. The value of `<address>` must be known by the time the `.PHASE` statement is reached (it can't be an expression containing a symbol that is defined later in code).
2. Segment change instructions (`ASEG`, `CSEG`, `DSEG`, `COMMON`) aren't allowed inside a phased block.

The second one is something that doesn't seem to be supported by Macro80 anyway: even though no errors are emitted, the location counter gets an incorrect value after a segment change instruction inside a phased block.


### .PRINT 🆕

_Syntax:_ `.PRINT <text>`

Prints a text to the terminal where the assembler is running (unless the `--silence-assembly-print` argument was passed to Nestor80). The message supports expression interpolation.

The text will be printed in both pass 1 and pass 2. Normally you'll want to print the text only in one of the passes, so you should either wrap the `.PRINT` instruction in an `IF1` or `IF2` block, or use the `.PRINT1` or `.PRINT2` instruction instead. See "Passes".


### .PRINT1 🆕

_Syntax:_ `.PRINT1 <text>`

Like `.PRINT`, but only prints the text in pass 1. See "Passes".


### .PRINT2 🆕

_Syntax:_ `.PRINT1 <text>`

Like `.PRINT`, but only prints the text in pass 2. See "Passes".


### .PRINTX

_Syntax:_ `.PRINTX <delimiter><text>[<delimiter>]`

Prints a text to the terminal where the assembler is running (unless the `--silence-assembly-print` argument was passed to Nestor80). The first character of the text is considered a delimiter, and the text is printed until either the delimiter is found again or the end of the line is found (the end delimiter itself is printed too). For example `.PRINTX /Foo` prints `Foo`, and `.PRINTX /Foo/bar` prints `/Foo/`.

This instruction is provided for compatibility with Macro80. New programs should use `.PRINT`, `.PRINT1` or `.PRINT2` instead, which don't need a delimiter and support expression interpolation.


### .RADIX

_Syntax:_ `.RADIX <value>`

Changes the default radix for the numeric constants that don't have a radix suffix. `<value>` must evaluate to a number between 2 and 16, and the default radix for numeric constants in `<value>` is 10 regardless of the current default radix.

Example:

```
db 12      ;12

.radix 16
db 12      ;18

.radix 2
db 1010    ;10
```


### .RELAB 🆕

_Syntax:_ `.RELAB`

Enables the relative labels feature. See also `.XRELAB`.


### .REQUEST ®

_Syntax:_ `.REQUEST <filename>[,<filename>[,...]]`

Defines a list of files in which the linker will search for any globals that remain undefined during the linking process. For compatibility with Link80 filenames must be up to 7 characters long, contain only ASCII letters, and can't contain an extension nor any drive or directory specification.


### PAGE (SUBPAGE 🆕, $EJECT)

_Syntax:_ `PAGE <page size>`

_Aliases:_ `SUBPAGE`, `$EJECT`


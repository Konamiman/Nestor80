using System.Text;

namespace Konamiman.Nestor80
{
    /// <summary>
    /// Parser for Microsoft Z80 relocatable files (generated by M80, processed by L80).
    /// </summary>
    public class RelFileParser
    {
        const byte ASCII_DOT = 0x2E;
        const byte LINK_ITEM_EXTENSION = 4;
        const byte LINK_ITEM_PROGRAM_END = 14;
        const byte LINK_ITEM_FILE_END = 15;

        private string[] addressTypes = {
            "", //Absolute
            "Code ",
            "Data ",
            "Common "
        };

        private string[] linkItemTypes = {
            "Entry symbol",
            "Select COMMON block",
            "Program name",
            "Request library search",
            "Extension link item",
            "Define COMMON size",
            "Chain external",
            "Define entry point",
            "External - offset",
            "External + offset",
            "Define size of Data area",
            "Set loading location counter",
            "Chain address",
            "Define program size",
            "End of program",
            "End of file"
        };

        private string[] arithmeticOperators = {
            "Store as byte",    //1
            "Store as word",    //2
            "HIGH",             //3
            "LOW",              //4
            "NOT",              //5
            "Unary -",          //6
            "-",                //7
            "+",                //8
            "*",                //9
            "/",                //10
            "MOD"               //11
        };

        private byte[] fileContents;

        private Action<string> print;

        /// <summary>
        /// Create a new instance of the class.
        /// </summary>
        /// <param name="fileContents">File contents to parse.</param>
        /// <param name="printer">Delegate to be used to print the generated information, by default it prints to console.</param>
        public RelFileParser(byte[] fileContents, Action<string> printer = null)
        {
            this.fileContents = fileContents;
            this.print = printer ?? Print;
        }

        private List<byte> cummulatedAbsoluteBytes = new List<byte>();

        /// <summary>
        /// Parse and print the contents of the file.
        /// </summary>
        public void ParseFile()
        {
            var bsr = new BitStreamReader(fileContents);
            cummulatedAbsoluteBytes.Clear();

            while(!bsr.EndOfStream) {
                var nextItemIsRelocatable = bsr.ReadBit();
                if(!nextItemIsRelocatable) {
                    var nextAbsoluteByte = bsr.ReadByte(8);
                    cummulatedAbsoluteBytes.Add(nextAbsoluteByte);
                    continue;
                }

                if(cummulatedAbsoluteBytes.Count > 0) {
                    PrintLine();
                    foreach(var item in cummulatedAbsoluteBytes) {
                        print($"{item:X2} ");
                    }
                    PrintLine();
                    PrintLine();
                    cummulatedAbsoluteBytes.Clear();
                }

                var relocatableItemType = bsr.ReadByte(2);
                if(relocatableItemType != 0) {
                    var relocatableItem = bsr.ReadUInt16(16);
                    PrintLine($"{addressTypes[relocatableItemType]}{relocatableItem:X4}");
                    continue;
                }

                var linkItemType = bsr.ReadByte(4);
                if(linkItemType == LINK_ITEM_FILE_END) {
                    PrintLine(linkItemTypes[LINK_ITEM_FILE_END]);
                    return;
                }

                if(linkItemType == LINK_ITEM_EXTENSION) {
                    ExtractExtensionLinkItem(bsr);
                    continue;
                }

                print($"{linkItemTypes[linkItemType]}");
                if(linkItemType >= 5) {
                    ExtractAItem(bsr);
                }
                if(linkItemType <= 7) {
                    ExtractBItem(bsr);
                }

                if(linkItemType == LINK_ITEM_PROGRAM_END) {
                    bsr.ForceByteBoundary();
                }

                PrintLine();
            } 
        }

        private void ExtractExtensionLinkItem(BitStreamReader bsr)
        {
            var specialLintItemSize = bsr.ReadByte(3) - 1;
            var specialLintItemType = bsr.ReadByte(8);
            var specialItemBytes = new byte[specialLintItemSize];
            for(int i = 0; i < specialLintItemSize; i++) {
                specialItemBytes[i] = bsr.ReadByte(8);
            }

            print($"{linkItemTypes[4]}, ");
            switch(specialLintItemType) {
                case 0x41:
                    var operatorType = specialItemBytes[0];
                    var operatorTypeString = operatorType < 1 || operatorType > 11 ? $"{operatorType:X2}" : $"{arithmeticOperators[operatorType - 1]}";
                    PrintLine($"Arith Operator, {operatorTypeString}");
                    break;
                case 0x42:
                    PrintLine($"Ref external, {ToAsciiString(specialItemBytes)}");
                    break;
                case 0x43:
                    var value = specialItemBytes[1] + (specialItemBytes[2] << 8);
                    PrintLine($"Value, {addressTypes[specialItemBytes[0]]}{value:X4}");
                    break;
                case 0x48:
                    PrintLine($"Common runtime header, file = {ToAsciiString(specialItemBytes)}");
                    break;
                default:
                    var specialItemBytesHex = specialItemBytes.Select(b => $"{b:X2}").ToArray();
                    var toprint = $"{specialLintItemType:X2}, {ToAsciiString(specialItemBytes)} ({string.Join(' ', specialItemBytesHex)})";
                    PrintLine(toprint);
                    break;
            }
        }

        private string ToAsciiString(byte[] data)
        {
            var bytes = data.Select(b => b >= 32 && b < 127 ? b : ASCII_DOT).ToArray();
            return Encoding.ASCII.GetString(bytes);
        }

        private void ExtractAItem(BitStreamReader bsr)
        {
            var addressType = bsr.ReadByte(2);
            var address = bsr.ReadUInt16(16);

            print($", {addressTypes[addressType]}{address:X4}");
        }

        private void ExtractBItem(BitStreamReader bsr)
        {
            var symbolLength = bsr.ReadByte(3);
            var symbolBytes = new byte[symbolLength];
            for(int i=0; i<symbolLength; i++) {
                symbolBytes[i] = bsr.ReadByte(8);
            }

            print($", {ToAsciiString(symbolBytes)}");
        }

        private void Print(string value)
        {
            Console.Write(value);
        }

        private void PrintLine(string value = "")
        {
            print(value);
            print(Environment.NewLine);
        }
    }
}
